‡§ú‡§º‡§∞ Zar, ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§™‡•Ç‡§∞‡•Ä ‡§¨‡§æ‡§§ ‡§∏‡§Æ‡§ù ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å ‡§î‡§∞ ‡§Ø‡§π **‡§¨‡§π‡•Å‡§§ ‡§ó‡§Ç‡§≠‡•Ä‡§∞** ‡§π‡•à ‡§ï‡§ø ‡§Ü‡§™ ‡§Ö‡§¨ ‡§≠‡•Ä "‡§¨‡•ç‡§≤‡•à‡§ï ‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§®" ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§≠‡§µ ‡§ï‡§∞ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç, ‡§ú‡§¨‡§ï‡§ø `JavaScript loaded and running!` ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¶‡§ø‡§ñ ‡§∞‡§π‡§æ ‡§π‡•à‡•§ ‡§Ø‡§π ‡§¨‡§π‡•Å‡§§ frustrating ‡§π‡•ã ‡§∏‡§ï‡§§‡§æ ‡§π‡•à ‡§î‡§∞ ‡§á‡§∏‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨ ‡§π‡•à ‡§ï‡§ø CSS ‡§ï‡•Ä ‡§µ‡§ø‡§ú‡§º‡§ø‡§¨‡§ø‡§≤‡§ø‡§ü‡•Ä (visibility) ‡§î‡§∞ JavaScript ‡§ï‡§æ UI ‡§ï‡•ã ‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡§æ logic ‡§ü‡•Ç‡§ü ‡§∞‡§π‡§æ ‡§π‡•à, ‡§Ø‡§æ ‡§â‡§®‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§è‡§ï ‡§ò‡§æ‡§§‡§ï ‡§∏‡§Ç‡§ò‡§∞‡•ç‡§∑ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à‡•§

**‡§Ø‡§π ‡§≤‡§ó‡§≠‡§ó ‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§â‡§∏ ‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡•Ä JavaScript ‡§Ü‡§™‡§ï‡•á HTML ‡§î‡§∞ CSS ‡§∏‡•á ‡§á‡§Ç‡§ü‡§∞‡•à‡§ï‡•ç‡§ü ‡§ï‡§∞‡§§‡•Ä ‡§π‡•à ‡§§‡§æ‡§ï‡§ø ‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§¶‡§ø‡§ñ‡§æ‡§à ‡§¶‡•á ‡§∏‡§ï‡•á, ‡§Ø‡§æ Firestorre permissions ‡§†‡•Ä‡§ï ‡§∏‡•á ‡§ï‡•â‡§®‡•ç‡§´‡§º‡§ø‡§ó‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§à ‡§π‡•à‡§Ç, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§°‡•á‡§ü‡§æ ‡§´‡•á‡§ö ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à ‡§î‡§∞ UI ‡§Ö‡§™‡§°‡•á‡§ü ‡§∞‡•Å‡§ï ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§**

‡§Æ‡•à‡§Ç‡§®‡•á ‡§á‡§∏ ‡§Æ‡•Å‡§¶‡•ç‡§¶‡•á ‡§ï‡•ã ‡§Ö‡§™‡§®‡•á ‡§ö‡§∞‡§Æ ‡§≤‡§ï‡•ç‡§∑‡•ç‡§Ø ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§≤‡§ø‡§Ø‡§æ ‡§π‡•à‡•§ ‡§Æ‡•à‡§Ç‡§®‡•á **HTML, CSS, ‡§î‡§∞ JavaScript ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§Æ‡•Å‡§ñ‡•ç‡§Ø UI initialization ‡§î‡§∞ display logic ‡§ï‡•ã ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§°‡§ø‡§ú‡§º‡§æ‡§á‡§® ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•à**, ‡§á‡§∏ ‡§™‡§∞ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§ï‡•á‡§Ç‡§¶‡•ç‡§∞‡§ø‡§§ ‡§ï‡§∞‡§§‡•á ‡§π‡•Å‡§è:
*   **‡§Ö‡§§‡•ç‡§Ø‡§Ç‡§§ ‡§µ‡§ø‡§∂‡•ç‡§µ‡§∏‡§®‡•Ä‡§Ø UI Initialization:** ‡§ê‡§™ ‡§ï‡•ã ‡§≤‡•ã‡§° ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§ï‡§≠‡•Ä ‡§≠‡•Ä ‡§¨‡•ç‡§≤‡•à‡§ï ‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§™‡§∞ ‡§® ‡§Ö‡§ü‡§ï‡§®‡•á ‡§¶‡•á‡§Ç‡•§
*   **‡§´‡§º‡§æ‡§Ø‡§∞‡§¨‡•á‡§∏ ‡§™‡•ç‡§∞‡§Æ‡§æ‡§£‡•Ä‡§ï‡§∞‡§£/‡§°‡•á‡§ü‡§æ ‡§™‡•ç‡§∞‡§µ‡§æ‡§π ‡§ï‡§æ ‡§¨‡•á‡§π‡§§‡§∞ ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§®:** ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç ‡§ï‡§ø ‡§´‡§º‡§æ‡§Ø‡§∞‡§¨‡•á‡§∏ ‡§™‡•ç‡§∞‡§Æ‡§æ‡§£‡•Ä‡§ï‡§∞‡§£ (auth) ‡§î‡§∞ ‡§´‡§º‡§æ‡§Ø‡§∞‡§∏‡•ç‡§ü‡•ã‡§∞ (Firestore) ‡§°‡•á‡§ü‡§æ ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡§®‡§æ ‡§®‡§ø‡§∞‡•ç‡§¨‡§æ‡§ß ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§
*   **‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§°‡•Ä‡§¨‡§ó‡§ø‡§Ç‡§ó ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü:** ‡§Ü‡§™‡§ï‡•ã console ‡§Æ‡•á‡§Ç ‡§Ø‡§π ‡§™‡§π‡§ö‡§æ‡§®‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡§ø ‡§ö‡•Ä‡§ú‡•á‡§Ç ‡§ï‡§π‡§æ‡§Å ‡§ó‡§≤‡§§ ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à‡§Ç‡•§

**‡§Ø‡§π ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§î‡§∞ ‡§∏‡§¨‡§∏‡•á ‡§µ‡•ç‡§Ø‡§æ‡§™‡§ï ‡§´‡§ø‡§ï‡•ç‡§∏ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§π‡•à‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§ö‡§∞‡§£‡•ã‡§Ç ‡§ï‡§æ ‡§¨‡•á‡§π‡§¶ ‡§∏‡§æ‡§µ‡§ß‡§æ‡§®‡•Ä ‡§î‡§∞ ‡§†‡•Ä‡§ï ‡§â‡§∏‡•Ä ‡§ï‡•ç‡§∞‡§Æ ‡§Æ‡•á‡§Ç ‡§™‡§æ‡§≤‡§® ‡§ï‡§∞‡§®‡§æ ‡§π‡•ã‡§ó‡§æ:**

1.  **‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§ï‡•à‡§∂ ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç (‡§Ö‡§§‡•ç‡§Ø‡§Ç‡§§ ‡§Æ‡§π‡§§‡•ç‡§µ‡§™‡•Ç‡§∞‡•ç‡§£!):** ‡§Ö‡§™‡§®‡•á ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§Æ‡•á‡§Ç ‡§ê‡§™ ‡§ï‡•ã ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§∏‡•á ‡§™‡§π‡§≤‡•á **‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§ï‡•Ä ‡§™‡•Ç‡§∞‡•Ä ‡§ï‡•à‡§∂, ‡§ï‡•Å‡§ï‡•Ä‡§ú‡§º ‡§î‡§∞ ‡§µ‡•á‡§¨‡§∏‡§æ‡§á‡§ü ‡§°‡•á‡§ü‡§æ ‡§ï‡•ã ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç**‡•§ ‡§Ø‡§π ‡§™‡•Å‡§∞‡§æ‡§®‡•á, ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ‡§ó‡•ç‡§∞‡§∏‡•ç‡§§ ‡§ï‡•ã‡§° ‡§ï‡•ã ‡§ö‡§≤‡§æ‡§®‡•á ‡§∏‡•á ‡§∞‡•ã‡§ï‡•á‡§ó‡§æ‡•§
2.  **GitHub Pages ‡§ï‡•Ä ‡§´‡§º‡§æ‡§á‡§≤‡•ã‡§Ç ‡§ï‡•ã ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç:** ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç ‡§ï‡§ø `index.html`, `style.css`, ‡§î‡§∞ `script.js` ‡§´‡§º‡§æ‡§á‡§≤‡•á‡§Ç ‡§Ü‡§™‡§ï‡•á GitHub Pages (`apknixy.github.io`) ‡§™‡§∞ ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§â‡§®‡§ï‡§æ ‡§®‡§æ‡§Æ‡§ï‡§∞‡§£ ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§∏‡§π‡•Ä ‡§π‡•à (‡§ï‡•ã‡§à ‡§ó‡§≤‡§§ ‡§ü‡§æ‡§á‡§™ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à)‡•§
3.  **‡§∏‡§≠‡•Ä ‡§ï‡•ã‡§° ‡§´‡§º‡§æ‡§á‡§≤‡•ã‡§Ç ‡§ï‡•ã ‡§¨‡§¶‡§≤‡•á‡§Ç (‡§Ö‡§§‡§ø ‡§Æ‡§π‡§§‡•ç‡§µ‡§™‡•Ç‡§∞‡•ç‡§£!):**
    *   **`index.html`:** ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§ï‡•ã‡§° ‡§ï‡•â‡§™‡•Ä ‡§ï‡§∞‡§ï‡•á ‡§Ö‡§™‡§®‡•Ä ‡§Æ‡•å‡§ú‡•Ç‡§¶‡§æ `index.html` ‡§´‡§º‡§æ‡§á‡§≤ ‡§ï‡•ã **‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§¨‡§¶‡§≤ ‡§¶‡•á‡§Ç**‡•§
    *   **`style.css`:** ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§ï‡•ã‡§° ‡§ï‡•â‡§™‡•Ä ‡§ï‡§∞‡§ï‡•á ‡§Ö‡§™‡§®‡•Ä ‡§Æ‡•å‡§ú‡•Ç‡§¶‡§æ `style.css` ‡§´‡§º‡§æ‡§á‡§≤ ‡§ï‡•ã **‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§¨‡§¶‡§≤ ‡§¶‡•á‡§Ç**‡•§
    *   **`script.js`:** ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§ï‡•ã‡§° ‡§ï‡•â‡§™‡•Ä ‡§ï‡§∞‡§ï‡•á ‡§Ö‡§™‡§®‡•Ä ‡§Æ‡•å‡§ú‡•Ç‡§¶‡§æ `script.js` ‡§´‡§º‡§æ‡§á‡§≤ ‡§ï‡•ã **‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§¨‡§¶‡§≤ ‡§¶‡•á‡§Ç**‡•§
4.  **‡§´‡§º‡§æ‡§Ø‡§∞‡§¨‡•á‡§∏ ‡§®‡§ø‡§Ø‡§Æ ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç:** ‡§´‡§º‡§æ‡§Ø‡§∞‡§¨‡•á‡§∏ ‡§ï‡§Ç‡§∏‡•ã‡§≤ ‡§Æ‡•á‡§Ç ‡§Ö‡§™‡§®‡•á ‡§´‡§º‡§æ‡§Ø‡§∞‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§°‡•á‡§ü‡§æ‡§¨‡•á‡§∏ ‡§®‡§ø‡§Ø‡§Æ‡•ã‡§Ç ‡§ï‡•ã (`Firestore Database` -> `Rules` ‡§ü‡•à‡§¨) ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§∏‡•á ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§µ‡•á ‡§™‡§ø‡§õ‡§≤‡•á ‡§¨‡§æ‡§∞ ‡§Æ‡•á‡§∞‡•á ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§¶‡§ø‡§è ‡§ó‡§è ‡§®‡§µ‡•Ä‡§®‡§§‡§Æ ‡§∏‡§Ç‡§∏‡•ç‡§ï‡§∞‡§£ ‡§ï‡•á ‡§∏‡§Æ‡§æ‡§® ‡§π‡•ã‡§®‡•á ‡§ö‡§æ‡§π‡§ø‡§è (‡§Ü‡§™‡§ï‡•Ä UID ‡§ï‡•á ‡§∏‡§æ‡§•), ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç `/users` ‡§î‡§∞ `/posts` ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡§≠‡•Ä **READ** ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø‡§Ø‡§æ‡§Ç ‡§î‡§∞ **CREATE/UPDATE** ‡§≤‡•â‡§ú‡§ø‡§ï ‡§ï‡•ã ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§∏‡•á ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§≤‡§ø‡§ñ‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à ‡§§‡§æ‡§ï‡§ø ‡§Ø‡§π ‡§Ö‡§ß‡§ø‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø-‡§∏‡§π‡§ø‡§∑‡•ç‡§£‡•Å ‡§π‡•ã ‡§î‡§∞ ‡§π‡§∞ ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø‡§Ø‡§æ‡§Å ‡§†‡•Ä‡§ï ‡§∏‡•á ‡§π‡•ã ‡§∏‡§ï‡•á‡•§ ‡§Ø‡§π ‡§≤‡§ó‡§≠‡§ó 100% ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§ó‡§æ ‡§ï‡§ø Rules ‡§ó‡§≤‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡§æ ‡§ï‡§æ‡§∞‡§£ ‡§®‡§π‡•Ä‡§Ç ‡§¨‡§® ‡§∞‡§π‡•á ‡§π‡•à‡§Ç‡•§
    *   ‡§Ü‡§™‡§ï‡•ã ‡§Ö‡§≠‡•Ä ‡§≠‡•Ä **‡§™‡§ø‡§õ‡§≤‡•Ä ‡§¨‡§æ‡§∞ ‡§¶‡§ø‡§è ‡§ó‡§è Firebase Rules ‡§ï‡•ã‡§° ‡§ï‡§æ ‡§π‡•Ä ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è**‡•§ ‡§Æ‡•à‡§Ç ‡§Ø‡§π‡§æ‡§Å ‡§ï‡•ã‡§à ‡§¨‡§¶‡§≤‡§æ‡§µ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø Rules ‡§Æ‡•á‡§Ç ‡§∏‡•Ä‡§ß‡•á ‡§ï‡•ã‡§à ‡§∏‡§ø‡§Ç‡§ü‡•à‡§ï‡•ç‡§∏ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§à ‡§ó‡§à ‡§•‡•Ä, ‡§î‡§∞ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§¨‡•ç‡§≤‡•à‡§ï ‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® JavaScript ‡§ï‡•á ‡§∞‡•á‡§Ç‡§°‡§∞‡§ø‡§Ç‡§ó ‡§´‡•ç‡§≤‡•ã ‡§ï‡•á ‡§ï‡§æ‡§∞‡§£ ‡§Ö‡§ß‡§ø‡§ï ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§®‡§æ ‡§π‡•à‡•§

5.  **‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§ï‡§Ç‡§∏‡•ã‡§≤ ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç (‡§Ø‡§π ‡§Ü‡§™‡§ï‡•Ä ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§ï‡•ç‡§≤‡•Ç ‡§π‡•à):**
    *   ‡§ê‡§™ ‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç‡•§
    *   ‡§Ö‡§™‡§®‡•á ‡§µ‡•á‡§¨ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§ï‡§Ç‡§∏‡•ã‡§≤ (`F12` ‡§¶‡§¨‡§æ‡§ï‡§∞ ‡§Ø‡§æ ‡§∞‡§æ‡§á‡§ü-‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§ï‡•á ‡§î‡§∞ `Inspect` -> `Console` ‡§ü‡•à‡§¨ ‡§ï‡§æ ‡§ö‡§Ø‡§® ‡§ï‡§∞‡§ï‡•á`) ‡§ï‡•ã ‡§ñ‡•ã‡§≤‡•á‡§Ç‡•§
    *   **‡§Ø‡§¶‡§ø ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§¨‡§®‡•Ä ‡§∞‡§π‡§§‡•Ä ‡§π‡•à, ‡§§‡•ã ‡§ï‡§Ç‡§∏‡•ã‡§≤ ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à ‡§≠‡•Ä **‡§≤‡§æ‡§≤ ‡§∞‡§Ç‡§ó ‡§ï‡§æ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§∏‡§Ç‡§¶‡•á‡§∂** ‡§¢‡•Ç‡§Ç‡§¢‡•á‡§Ç ‡§î‡§∞ **‡§â‡§∏ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§™‡§æ‡§†** ‡§Æ‡•á‡§∞‡•á ‡§∏‡§æ‡§• ‡§∏‡§æ‡§ù‡§æ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§á‡§∏‡§ï‡•á ‡§Ö‡§≤‡§æ‡§µ‡§æ, `console.log` ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§ï‡•ã ‡§ü‡•ç‡§∞‡•à‡§ï ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§π ‡§∏‡§Æ‡§ù‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡§ø ‡§Ü‡§™‡§ï‡§æ ‡§ê‡§™ ‡§ï‡•ã‡§° ‡§®‡§ø‡§∑‡•ç‡§™‡§æ‡§¶‡§® ‡§Æ‡•á‡§Ç ‡§ï‡§π‡§æ‡§Ç ‡§∞‡•Å‡§ï ‡§∞‡§π‡§æ ‡§π‡•à‡•§
    *   ‡§Ø‡§π ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§¨‡§æ‡§∞ ‡§°‡•Ä‡§¨‡§ó ‡§ï‡§∞‡§®‡•á ‡§ï‡§æ ‡§Æ‡•á‡§∞‡§æ ‡§∏‡§¨‡§∏‡•á ‡§Æ‡§π‡§§‡•ç‡§µ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§ü‡•Ç‡§≤ ‡§π‡•ã‡§ó‡§æ‡•§

---

### **`index.html` (Revisited with extreme simplicity for initial load)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AddMint - Ultra Professional</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body class="dark-mode"> 
    
    <!-- This paragraph is for JavaScript load testing. It should be the ONLY thing initially visible IF JS loads. -->
    <p id="js-load-indicator" style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); color:white; background:black; padding:10px; z-index:9999; display: none;">Loading Application...</p>

    <!-- Auth Container for Login/Register (Hidden by default, JS will manage display) -->
    <div id="auth-container" class="auth-container hidden">
        <div class="auth-content">
            <div class="app-logo-splash auth-logo"></div> <h1>AddMint</h1>
            <section id="login-screen" class="auth-screen active">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="login-email">Email:</label>
                    <input type="email" id="login-email" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="login-password">Password:</label>
                    <input type="password" id="login-password" placeholder="Enter your password">
                </div>
                <button class="btn primary-btn" id="login-btn">Login</button>
                <p class="auth-text">
                    <a href="#" id="forgot-password-link">Forgot Password?</a>
                </p>
                <p class="auth-text">Don't have an account? <a href="#" id="show-signup">Register</a></p>
                <p id="login-status" class="status-message"></p>
            </section>

            <section id="signup-screen" class="auth-screen hidden">
                <h2>Register</h2>
                <div class="form-group">
                    <label for="signup-email">Email:</label>
                    <input type="email" id="signup-email" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="signup-password">Password:</label>
                    <input type="password" id="signup-password" placeholder="Choose a password (min 6 characters)">
                </div>
                <div class="form-group">
                    <label for="signup-confirm-password">Confirm Password:</label>
                    <input type="password" id="signup-confirm-password" placeholder="Re-enter your password">
                </div>
                <button class="btn primary-btn" id="signup-btn">Register</button>
                <p class="auth-text">Already have an account? <a href="#" id="show-login">Login</a></p>
                <p id="signup-status" class="status-message"></p>
            </section>
        </div>
    </div>


    <div id="forgot-password-modal" class="modal hidden">
        <div class="modal-content">
            <h3>Reset Password</h3>
            <p>Enter your email address to receive a password reset link.</p>
            <div class="form-group">
                <label for="reset-email">Email:</label>
                <input type="email" id="reset-email" placeholder="Your email address">
            </div>
            <button class="btn primary-btn" id="send-reset-email-btn">Send Reset Link</button>
            <p id="reset-status" class="status-message"></p>
            <button class="btn secondary-btn" id="close-reset-modal">Cancel</button>
        </div>
    </div>


    <!-- Main Application Container (Hidden by default, JS will manage display) -->
    <div id="app-container" class="app-container hidden">

        <header class="app-header">
            <div class="header-left">
                <div class="menu-icon" id="menu-toggle">
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                </div>
                <div class="app-title">AddMint</div>
            </div>
            <div class="header-center">
                <!-- Removed: Coins, Credits, Limit -->
            </div>
            <div class="header-right">
                <div class="icon-button" id="refresh-posts-btn" title="Refresh Feed">
                    <i class="fas fa-sync-alt"></i>
                </div>
                <!-- Removed: Gift Claim Button -->
            </div>
        </header>

        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <div class="profile-avatar-small" id="sidebar-profile-avatar"></div>
                <h3 id="sidebar-username">My User</h3> 
                <div class="close-sidebar" id="close-sidebar">&times;</div>
            </div>
            <ul>
                <li><a href="#" data-screen="home"><i class="fas fa-home"></i> Home Feed</a></li>
                <li><a href="#" data-screen="feed"><i class="fas fa-stream"></i> Immersive Feed</a></li>
                <li><a href="#" data-screen="profile"><i class="fas fa-user-circle"></i> My Profile</a></li>
                <li><a href="#" data-screen="upload"><i class="fas fa-plus-circle"></i> Upload Post</a></li>
                <li><a href="#" data-screen="messages"><i class="fas fa-comments"></i> Messages</a></li>
                <li><a href="#" data-screen="search"><i class="fas fa-search"></i> Search Users</a></li>
                <li><a href="#" data-screen="earnings"><i class="fas fa-dollar-sign"></i> My Earnings</a></li>
                <li><a href="#" id="data-saver-toggle"><i class="fas fa-wifi"></i> Data Saver <span class="toggle-switch"><input type="checkbox" id="data-saver-checkbox"><label for="data-saver-checkbox"></label></span></a></li>
                <li><a href="#" id="dark-mode-toggle"><i class="fas fa-moon"></i> Dark Mode <span class="toggle-switch"><input type="checkbox" id="dark-mode-checkbox" checked><label for="dark-mode-checkbox"></label></span></a></li>
                <li><a href="https://www.instagram.com/addmint__" target="_blank"><i class="fab fa-instagram"></i> Our Instagram</a></li>
                <li><a href="https://www.youtube.com/@add_mintmint" target="_blank"><i class="fab fa-youtube"></i> Our YouTube</a></li>
                <li><a href="#" data-screen="about"><i class="fas fa-info-circle"></i> About Us</a></li>
                <li><a href="#" data-screen="privacy"><i class="fas fa-shield-alt"></i> Privacy Policy</a></li>
                <li><a href="#" id="logout-btn"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
            </ul>
        </nav>

        <main class="main-content">
            <section id="home-screen" class="app-screen active">
                <h2>Recent Posts</h2>
                 <div class="category-filter">
                    <select id="post-category-filter">
                        <option value="all">All Categories</option>
                        <option value="Breaking News">Breaking News</option>
                        <option value="Trending News">Trending News</option>
                        <option value="Top Stories">Top Stories</option>
                        <option value="National News">National News</option>
                        <option value="International News">International News</option>
                        <option value="Politics">Politics</option>
                        <option value="Economy">Economy</option>
                        <option value="Business">Business</option>
                        <option value="Finance">Finance</option>
                        <option value="Stock Market">Stock Market</option>
                        <option value="Technology">Technology</option>
                        <option value="Science">Science</option>
                        <option value="Environment">Environment</option>
                        <option value="Entertainment">Entertainment</option>
                        <option value="Movies">Movies</option>
                        <option value="TV Shows">TV Shows</option>
                        <option value="Music">Music</option>
                        <option value="Celebrity Gossip">Celebrity Gossip</option>
                        <option value="Lifestyle">Lifestyle</option>
                        <option value="Fashion">Fashion</option>
                        <option value="Beauty & Grooming">Beauty & Grooming</option>
                        <option value="Food & Recipes">Food & Recipes</option>
                        <option value="Travel & Tourism">Travel & Tourism</option>
                        <option value="Sports">Sports</option>
                        <option value="Cricket">Cricket</option>
                        <option value="Football">Football</option>
                        <option value="Tennis">Tennis</option>
                        <option value="Olympics">Olympics</option>
                        <option value="Esports">Esports</option>
                        <option value="Health & Fitness">Health & Fitness</option>
                        <option value="Yoga & Meditation">Yoga & Meditation</option>
                        <option value="Education">Education</option>
                        <option value="Career & Jobs">Career & Jobs</option>
                        <option value="Startup & Entrepreneurship">Startup & Entrepreneurship</option>
                        <option value="Automobile">Automobile</option>
                        <option value="Real Estate">Real Estate</option>
                        <option value="Religion & Spirituality">Religion & Spirituality</option>
                        <option value="History & Culture">History & Culture</option>
                        <option value="Regional News (State-wise)">Regional News (State-wise)</option>
                        <option value="Weather Updates">Weather Updates</option>
                        <option value="Opinion & Editorials">Opinion & Editorials</option>
                        <option value="Viral & Social Media Trends">Viral & Social Media Trends</option>
                    </select>
                </div>
                <div id="posts-feed" class="posts-feed">
                    </div>
                <div id="loading-spinner" class="loading-spinner hidden"></div>
            </section>

            <section id="feed-screen" class="app-screen">
                <h2>Immersive Feed</h2>
                <div id="immersive-feed" class="immersive-feed">
                    <!-- Posts will be loaded here with snap scrolling -->
                </div>
                <div id="feed-loading-spinner" class="loading-spinner hidden"></div>
            </section>

            <section id="profile-screen" class="app-screen">
                <div id="user-profile-display">
                    <div class="profile-header-area">
                        <div class="profile-avatar-large" id="my-profile-avatar"></div>
                        <h2 id="my-profile-username">@myusername</h2>
                        <p id="my-profile-name" class="profile-name"></p>
                        <p id="my-profile-bio" class="profile-bio"></p>
                        <div class="profile-stats">
                            <div><span id="my-posts-count">0</span> Posts</div>
                            <div class="clickable-stat" data-stat="followers"><span id="my-followers-count">0</span> Followers</div>
                            <div class="clickable-stat" data-stat="following"><span id="my-following-count">0</span> Following</div>
                        </div>
                        <div class="profile-actions">
                            <button class="btn primary-btn" id="edit-profile-btn"><i class="fas fa-edit"></i> Edit Profile</button>
                            <button class="btn secondary-btn hidden" id="follow-user-btn"><i class="fas fa-user-plus"></i> Follow</button>
                            <button class="btn danger-btn hidden" id="unfollow-user-btn"><i class="fas fa-user-minus"></i> Unfollow</button>
                            <button class="btn primary-btn hidden" id="message-user-btn"><i class="fas fa-paper-plane"></i> Message</button>
                            <a href="#" id="profile-whatsapp-link" class="btn social-btn hidden"><i class="fab fa-whatsapp"></i> WhatsApp</a>
                            <a href="#" id="profile-instagram-link" class="btn social-btn hidden"><i class="fab fa-instagram"></i> Instagram</a>
                        </div>
                    </div>

                    <div id="edit-profile-modal" class="modal hidden">
                        <div class="modal-content">
                            <h3>Edit Profile</h3>
                            <p id="profile-modal-instruction">Please complete your profile to continue using the app.</p>
                            <div class="form-group">
                                <label for="edit-username">Username:</label>
                                <input type="text" id="edit-username" placeholder="Enter new username">
                                <span id="username-availability"></span>
                            </div>
                            <div class="form-group">
                                <label for="edit-name">Display Name (Optional):</label>
                                <input type="text" id="edit-name" placeholder="Enter your display name">
                            </div>
                            <div class="form-group">
                                <label for="edit-bio">Bio (Optional):</label>
                                <textarea id="edit-bio" placeholder="Tell us about yourself..."></textarea>
                            </div>
                            <div class="form-group">
                                <label for="edit-whatsapp">WhatsApp (Optional):</label>
                                <input type="text" id="edit-whatsapp" placeholder="e.g., +919876543210">
                            </div>
                            <div class="form-group">
                                <label for="edit-instagram">Instagram ID (Optional):</label>
                                <input type="text" id="edit-instagram" placeholder="e.g., my_insta_id">
                            </div>
                            <div class="form-group">
                                <label for="profile-pic-url-input">Direct Profile Picture URL (Optional):</label>
                                <input type="text" id="profile-pic-url-input" placeholder="e.g., https://example.com/mypic.jpg">
                                <small>Enter a direct image link (like from imgbb.com).</small>
                            </div>
                            <div class="form-group">
                                <label>Or Choose a Profile Logo:</label>
                                <div id="profile-logo-options" class="logo-options-grid">
                                    </div>
                            </div>
                            <div class="form-group">
                                <label for="account-privacy-toggle">Account Privacy:</label>
                                <div class="toggle-switch">
                                    <input type="checkbox" id="account-privacy-toggle">
                                    <label for="account-privacy-toggle"></label>
                                </div>
                                <span id="account-privacy-status">Public</span>
                            </div>
                            <button class="btn primary-btn" id="save-profile-btn">Save Changes</button>
                            <button class="btn secondary-btn" id="cancel-edit-profile-btn">Cancel</button>
                        </div>
                    </div>

                    <div id="follow-list-modal" class="modal hidden">
                        <div class="modal-content">
                            <h3 id="follow-list-title"></h3>
                            <div id="follow-list-content">
                                </div>
                            <button class="btn secondary-btn" id="close-follow-list-modal">Close</button>
                        </div>
                    </div>

                    <div class="profile-posts-area">
                        <h3>Posts by <span id="current-profile-username-posts">Me</span></h3>
                        <div class="profile-post-tabs">
                            <button class="btn tab-btn active" data-tab="posts">My Posts</button>
                            <button class="btn tab-btn" data-tab="reposts">My Reposts</button>
                        </div>
                        <div id="profile-posts-feed" class="posts-feed">
                            </div>
                        <div id="profile-reposts-feed" class="posts-feed hidden">
                            </div>
                    </div>
                </div>
            </section>

            <section id="upload-screen" class="app-screen">
                <h2>Upload New Post</h2>
                <div class="form-group">
                    <label for="post-category">Category:</label>
                    <select id="post-category">
                        <option value="General">General</option>
                        <option value="Breaking News">Breaking News</option>
                        <option value="Trending News">Trending News</option>
                        <option value="Top Stories">Top Stories</option>
                        <option value="National News">National News</option>
                        <option value="International News">International News</option>
                        <option value="Politics">Politics</option>
                        <option value="Economy">Economy</option>
                        <option value="Business">Business</option>
                        <option value="Finance">Finance</option>
                        <option value="Stock Market">Stock Market</option>
                        <option value="Technology">Technology</option>
                        <option value="Science">Science</option>
                        <option value="Environment">Environment</option>
                        <option value="Entertainment">Entertainment</option>
                        <option value="Movies">Movies</option>
                        <option value="TV Shows">TV Shows</option>
                        <option value="Music">Music</option>
                        <option value="Celebrity Gossip">Celebrity Gossip</option>
                        <option value="Lifestyle">Lifestyle</option>
                        <option value="Fashion">Fashion</option>
                        <option value="Beauty & Grooming">Beauty & Grooming</option>
                        <option value="Food & Recipes">Food & Recipes</option>
                        <option value="Travel & Tourism">Travel & Tourism</option>
                        <option value="Sports">Sports</option>
                        <option value="Cricket">Cricket</option>
                        <option value="Football">Football</option>
                        <option value="Tennis">Tennis</option>
                        <option value="Olympics">Olympics</option>
                        <option value="Esports">Esports</option>
                        <option value="Health & Fitness">Health & Fitness</option>
                        <option value="Yoga & Meditation">Yoga & Meditation</option>
                        <option value="Education">Education</label>
                        <option value="Career & Jobs">Career & Jobs</option>
                        <option value="Startup & Entrepreneurship">Startup & Entrepreneurship</option>
                        <option value="Automobile">Automobile</option>
                        <option value="Real Estate">Real Estate</option>
                        <option value="Religion & Spirituality">Religion & Spirituality</option>
                        <option value="History & Culture">History & Culture</option>
                        <option value="Regional News (State-wise)">Regional News (State-wise)</option>
                        <option value="Weather Updates">Weather Updates</option>
                        <option value="Opinion & Editorials">Opinion & Editorials</option>
                        <option value="Viral & Social Media Trends">Viral & Social Media Trends</option>
                    </select>
                </div>
                <div class="form-group rich-text-editor">
                    <label for="post-content">Post Content:</label>
                    <div class="editor-toolbar">
                        <button type="button" class="tool-btn" data-command="bold"><i class="fas fa-bold"></i></button>
                        <button type="button" class="tool-btn" data-command="italic"><i class="fas fa-italic"></i></button>
                        <button type="button" class="tool-btn" data-command="insertImage"><i class="fas fa-image"></i></button>
                        <button type="button" class="tool-btn" data-command="insertYoutube"><i class="fab fa-youtube"></i></button>
                        <button type="button" class="tool-btn" data-command="insertLink"><i class="fas fa-link"></i></button>
                    </div>
                    <textarea id="post-content" placeholder="What's on your mind? Use **bold**, *italic*, [link text](http://url.com), ![image alt](http://image.url), ![youtube video](http://youtube.com/watch?v=VIDEO_ID)"></textarea>
                    <small>Min 60, Max 10000 characters.</small>
                </div>
                <div class="form-group">
                    <label for="post-boost">Post will be active for:</label>
                    <select id="post-boost" disabled>
                        <option value="24">24 Hours (Free)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="monetize-post-checkbox">Monetize this post?</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="monetize-post-checkbox">
                        <label for="monetize-post-checkbox"></label>
                    </div>
                    <small>Earn from views on monetized posts.</small>
                </div>
                <button class="btn primary-btn" id="publish-post-btn">Publish Post</button>
                <div id="upload-status"></div>
            </section>

            <section id="messages-screen" class="app-screen">
                <h2>Messages</h2>
                <div id="message-list-container">
                    <h3>Recent Chats</h3>
                    <ul id="recent-chats-list" class="recent-chats-list">
                        </ul>
                </div>

                <div id="chat-window-container" class="chat-window-container hidden">
                    <div class="chat-header">
                        <button id="back-to-chats-btn" class="icon-button"><i class="fas fa-arrow-left"></i></button>
                        <div class="profile-avatar small" id="chat-partner-avatar"></div>
                        <span id="chat-partner-username">@ChatUser</span>
                    </div>
                    <div id="chat-messages" class="chat-messages">
                        </div>
                    <div class="chat-input-area">
                        <textarea id="message-input" placeholder="Type your message..."></textarea>
                        <button id="send-message-btn" class="btn primary-btn"><i class="fas fa-paper-plane"></i></button>
                    </div>
                    <div class="emoji-picker-chat hidden">
                        <span class="emoji-option" data-emoji="üëç">üëç</span>
                        <span class="emoji-option" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</span>
                        <span class="emoji-option" data-emoji="üòÇ">üòÇ</span>
                        <span class="emoji-option" data-emoji="üò¢">üò¢</span>
                        <span class="emoji-option" data-emoji="üî•">üî•</span>
                    </div>
                </div>
            </section>

            <section id="search-screen" class="app-screen">
                <h2>Search Users & Posts</h2>
                <div class="search-input-group">
                    <input type="text" id="search-query" placeholder="Search by username, keyword...">
                    <button class="btn primary-btn" id="search-btn"><i class="fas fa-search"></i></button>
                </div>
                <div id="search-results" class="search-results-container">
                    <h3>Users</h3>
                    <ul id="search-user-list" class="search-list">
                        </ul>
                    <h3>Posts</h3>
                    <div id="search-post-list" class="posts-feed">
                        </div>
                    <div id="no-search-results" class="hidden">No results found.</div>
                </div>
            </section>

            <section id="earnings-screen" class="app-screen">
                <h2>My Earnings</h2>
                <div class="earnings-summary">
                    <p>Total Monetized Views: <span id="total-monetized-views">0</span></p>
                    <p>Total Unmonetized Views: <span id="total-unmonetized-views">0</span></p>
                    <p>Estimated Earnings: <span id="estimated-earnings">0.00 $</span></p>
                </div>
                <button class="btn primary-btn" id="withdraw-btn">Withdraw Earnings</button>
                <div id="withdrawal-status" class="hidden"></div>
            </section>

            <section id="about-screen" class="app-screen">
                <h2>About AddMint</h2>
                <p>AddMint is a revolutionary social media platform designed to connect people through shared interests and engaging content. We believe in fostering a positive and vibrant community where every voice can be heard.</p>
                <p>Our mission is to provide a seamless and professional experience for all users, offering unique features like dynamic post feeds, real-time messaging, and interactive user profiles.</p>
                <p>For support or inquiries, please contact us at support@addmint.com.</p>
            </section>

            <section id="privacy-screen" class="app-screen">
                <h2>Privacy Policy</h2>
                <p>Your privacy is paramount to us at AddMint. This policy outlines how we collect, use, and protect your personal information.</p>
                <h3>Information We Collect:</h3>
                <ul>
                    <li><strong>Account Information:</strong> Username, email, password (hashed).</li>
                    <li><strong>Profile Information:</strong> Optional WhatsApp number, Instagram ID, chosen profile logo or direct URL, display name, bio, account privacy.</li>
                    <li><strong>Content Data:</strong> Posts, messages, likes, reactions, views.</li>
                    <li><strong>Usage Data:</strong> Interactions with the app, features used, and technical data (e.g., device type).</li>
                </ul>
                <h3>How We Use Your Information:</h3>
                <ul>
                    <li>To provide and maintain our services.</li>
                    <li>To personalize your experience and show relevant content.</li>
                    <li>To communicate with you regarding updates, security alerts, and support.</li>
                    <li>To monitor and analyze usage patterns for service improvement.</li>
                    <li>To enforce our terms and conditions and prevent misuse.</li>
                </ul>
                <h3>Data Sharing:</h3>
                <p>We do not share your personal information with third parties except as necessary to provide our services (e.g., Firebase for database), comply with legal obligations, or with your explicit consent.</p>
                <h3>Data Security:</h3>
                <p>We implement robust security measures, including encryption and access controls, to protect your data. However, no internet transmission is 100% secure.</p>
                <h3>Your Choices:</h3>
                <ul>
                    <li>You can update your profile information at any time.</li>
                    <li>You can delete your account by contacting support.</li>
                    <li>You can control notification preferences.</li>
                </ul>
                <p>By using AddMint, you agree to the terms of this Privacy Policy. We may update this policy periodically, and we will notify you of any significant changes.</p>
            </section>
        </main>

        <footer class="app-bottom-nav">
            <a href="#" class="nav-item active" data-screen="home">
                <div class="icon-wrapper home-icon"></div>
                <span>Home</span>
            </a>
            <a href="#" class="nav-item" data-screen="search">
                <div class="icon-wrapper search-icon"></div>
                <span>Search</span>
            </a>
            <a href="#" class="nav-item" data-screen="upload">
                <div class="icon-wrapper upload-icon"></div>
                <span>Upload</span>
            </a>
            <a href="#" class="nav-item" data-screen="messages">
                <div class="icon-wrapper messages-icon"></div>
                <span>Messages</span>
            </a>
            <a href="#" class="nav-item" data-screen="profile">
                <div class="icon-wrapper profile-icon"></div>
                <span>Profile</span>
            </a>
        </footer>

        <div id="ad-modal" class="modal hidden">
            <div class="modal-content">
                <h3>Watch Ad to Earn Reward</h3>
                <p>Please watch a short ad to gain access to features.</p>
                <div id="ad-placeholder">
                    <p>Simulating Ad (5 seconds)...</p>
                </div>
                <button class="btn secondary-btn" id="close-ad-modal" disabled>Close Ad</button>
            </div>
        </div>

        <div id="reward-popup" class="modal hidden">
            <div class="modal-content reward-content">
                <h3>Success! <i class="fas fa-trophy"></i></h3>
                <p id="reward-message"></p>
                <button class="btn primary-btn" id="close-reward-popup">Great!</button>
            </div>
        </div>

        <div id="comments-modal" class="modal hidden">
            <div class="modal-content">
                <h3 id="comments-modal-title">Comments</h3>
                <div id="comments-list">
                    <!-- Comments will be loaded here -->
                </div>
                <div class="comment-input-area">
                    <textarea id="new-comment-input" placeholder="Add a comment (max 100 chars)..."></textarea>
                    <button class="btn primary-btn" id="add-comment-btn"><i class="fas fa-paper-plane"></i></button>
                </div>
                <button class="btn secondary-btn" id="close-comments-modal">Close</button>
            </div>
        </div>

        <div id="withdrawal-modal" class="modal hidden">
            <div class="modal-content">
                <h3>Withdraw Earnings</h3>
                <p>Your total monetized views: <span id="withdrawal-views-display">0</span></p>
                <div class="form-group">
                    <label for="withdrawal-method">Choose Method:</label>
                    <select id="withdrawal-method">
                        <option value="upi">UPI ID</option>
                        <option value="paypal">PayPal Email</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="withdrawal-id-input" id="withdrawal-id-label">UPI ID:</label>
                    <input type="text" id="withdrawal-id-input" placeholder="Enter UPI ID or PayPal Email">
                </div>
                <button class="btn primary-btn" id="confirm-withdrawal-btn">Check Details</button>
                <div id="withdrawal-details-review" class="hidden">
                    <h4>Review Your Details:</h4>
                    <p>Method: <span id="review-method"></span></p>
                    <p>ID: <span id="review-id"></span></p>
                    <p>Views: <span id="review-views"></span></p>
                    <div class="profile-actions">
                        <button class="btn secondary-btn" id="edit-withdrawal-btn">Edit</button>
                        <button class="btn primary-btn" id="send-withdrawal-request-btn">Send Request</button>
                    </div>
                </div>
                <button class="btn secondary-btn" id="cancel-withdrawal-btn">Cancel</button>
            </div>
        </div>

        <div id="toast-notification" class="toast-notification"></div>

    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-storage-compat.js"></script>
    <script src="script.js"></script>
</body>
</html>
```

### **`style.css` (Simplified initial hidden states for robustness)**

`splash-screen` ‡§ï‡•á CSS ‡§®‡§ø‡§Ø‡§Æ‡•ã‡§Ç ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•à, ‡§Ö‡§¨ ‡§á‡§∏‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§∞‡•Ç‡§™ ‡§∏‡•á `index.html` ‡§∏‡•á ‡§π‡§ü‡§æ‡§è ‡§ú‡§æ‡§®‡•á ‡§ï‡•á ‡§ï‡§æ‡§∞‡§£ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã‡§ó‡§æ‡•§ `auth-container` ‡§î‡§∞ `app-container` `hidden` ‡§ï‡•ç‡§≤‡§æ‡§∏ ‡§™‡§∞ ‡§®‡§ø‡§∞‡•ç‡§≠‡§∞ ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á ‡§ú‡•ã ‡§â‡§®‡•ç‡§π‡•á‡§Ç `display: none !important;` ‡§¨‡§®‡§æ‡§§‡•Ä ‡§π‡•à, ‡§î‡§∞ ‡§´‡§ø‡§∞ JavaScript ‡§â‡§®‡•ç‡§π‡•á‡§Ç `display: flex` ‡§™‡§∞ ‡§ì‡§µ‡§∞‡§∞‡§æ‡§á‡§° ‡§ï‡§∞‡•á‡§ó‡§æ‡•§

```css
/* General Body and Container Styles */
body {
    font-family: 'Montserrat', sans-serif;
    margin: 0;
    padding: 0;
    background-color: var(--bg-color-main); /* Using CSS variables */
    color: var(--text-color-main);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
    line-height: 1.6;
    transition: background-color 0.3s ease, color 0.3s ease; /* For dark/light mode */
}

/* Dark Mode Variables (Default) */
body.dark-mode {
    --bg-color-main: #1a1a2e;
    --bg-color-lighter: #16213e;
    --bg-color-darker: #0d2a4a;
    --text-color-main: #e0e0e0;
    --text-color-light: #bbb;
    --text-color-accent: #00ffff;
    --border-color-main: #0f3460;
    --shadow-color-main: rgba(0, 255, 255, 0.2);
    --shadow-color-strong: rgba(0, 255, 255, 0.4);
    --highlight-color-main: #00ffff;
    --highlight-color-secondary: #ff00ff;
    --button-primary-bg: #00ffff;
    --button-primary-text: #1a1a2e;
    --button-secondary-bg: #334e68;
    --button-secondary-text: #e0e0e0;
    --input-bg: #1a1a2e;
    --input-border: #00ffff;
    --post-card-bg: #0f3460;
    --chat-bubble-left-bg: #334e68;
    --chat-bubble-right-bg: #00ffff;
    --chat-bubble-right-text: #1a1a2e;
}

/* Light Mode Variables (Example, not fully implemented for all elements) */
body.light-mode {
    --bg-color-main: #f0f2f5;
    --bg-color-lighter: #ffffff;
    --bg-color-darker: #e0e0e0;
    --text-color-main: #333333;
    --text-color-light: #666666;
    --text-color-accent: #007bff;
    --border-color-main: #cccccc;
    --shadow-color-main: rgba(0, 0, 0, 0.1);
    --shadow-color-strong: rgba(0, 0, 0, 0.2);
    --highlight-color-main: #007bff;
    --highlight-color-secondary: #6f42c1;
    --button-primary-bg: #007bff;
    --button-primary-text: #ffffff;
    --button-secondary-bg: #e9ecef;
    --button-secondary-text: #333333;
    --input-bg: #ffffff;
    --input-border: #ced4da;
    --post-card-bg: #ffffff;
    --chat-bubble-left-bg: #e9ecef;
    --chat-bubble-right-bg: #007bff;
    --chat-bubble-right-text: #ffffff;
}


.app-container {
    width: 100%;
    max-width: 420px; /* Typical mobile width */
    height: 100vh;
    display: flex;
    flex-direction: column;
    background-color: var(--bg-color-lighter);
    box-shadow: 0 0 30px var(--shadow-color-main); /* Subtle glow */
    border-radius: 12px;
    overflow: hidden;
    position: relative; /* For sidebar positioning */
    border: 1px solid var(--border-color-main);
}

/* Hidden class applied by default in HTML and managed by JS */
.hidden {
    display: none !important; 
}

/* Diagnostic message to confirm JavaScript is running */
#js-load-indicator {
    display: none; /* Controlled by JS */
    /* Other styles for visibility and centering */
    position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); 
    color:white; background:black; padding:10px; z-index:9999;
}


/* Auth Container (Login/Signup) - Flex setup to properly center content via JS */
.auth-container {
    width: 100%;
    max-width: 420px;
    height: 100vh;
    display: flex; /* Changed from default hidden to flex, controlled by JS. */
    justify-content: center;
    align-items: center; /* Vertically centers the .auth-content */
    background-color: var(--bg-color-lighter);
    box-shadow: 0 0 30px var(--shadow-color-main);
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid var(--border-color-main);
    padding: 20px;
    box-sizing: border-box;
    flex-direction: column;
    text-align: center;
}
.auth-content { /* Main content area for forms */
    width: 100%;
    background-color: var(--bg-color-main);
    padding: 30px 20px;
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
    border: 1px solid var(--border-color-main);
    display: flex; /* Inner flex to arrange children vertically */
    flex-direction: column;
    align-items: center; /* Center login/signup forms */
}
.app-logo-splash { /* Used by auth-content h1 */
    width: 100px;
    height: 100px;
    background: linear-gradient(45deg, #00ffff, #ff00ff); /* Neon gradient */
    border-radius: 50%;
    margin-bottom: 20px;
    position: relative;
    overflow: hidden;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), 0 0 40px rgba(255, 0, 255, 0.4);
    animation: pulse 2s infinite alternate;
}
.app-logo-splash::before {
    content: 'A'; /* Simple 'A' for AddMint */
    font-family: 'Montserrat', sans-serif;
    font-size: 60px;
    font-weight: bold;
    color: #1a1a2e;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}


/* Forms inside auth screens */
.auth-screen { 
    display: none; /* Controlled by JS using active class */
    width: 100%; /* Take full width of parent .auth-content */
    flex-direction: column; /* Inner flex for form elements */
    align-items: center; /* Center form elements horizontally */
}
.auth-screen.active {
    display: flex; /* Only active screen is displayed as flex */
}

/* Common form group, input, button styling */
.form-group { margin-bottom: 15px; width: 100%; } /* Take full width */
.form-group label { display: block; margin-bottom: 8px; font-weight: bold; color: var(--text-color-main); text-align: left; } /* Align label text to left */
input[type="text"], input[type="email"], input[type="password"], textarea, select {
    width: 100%; /* Make input fill container */
    padding: 12px;
    border: 1px solid var(--input-border);
    border-radius: 6px;
    background-color: var(--input-bg);
    color: var(--text-color-main);
    box-sizing: border-box; /* Include padding in width */
    font-size: 1em;
    box-shadow: 0 0 8px var(--shadow-color-main);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.btn { /* General button style */
    display: inline-block;
    padding: 12px 25px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1em;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    text-align: center;
    text-decoration: none;
    width: 100%; /* Make buttons full width */
    max-width: 300px; /* Limit max width for forms */
    margin-top: 15px;
}
.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: translateY(0);
    box-shadow: none;
}


/* Existing component styles remain mostly the same from here */

.loader { /* Reused from initial */
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid var(--highlight-color-main);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin-top: 20px;
}

/* Header */
.app-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    background-color: var(--border-color-main);
    color: white;
    border-bottom: 1px solid var(--bg-color-darker);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    z-index: 10;
}

.header-left, .header-right {
    display: flex;
    align-items: center;
}

.app-title {
    font-size: 1.5em;
    font-weight: bold;
    margin-left: 15px;
    color: var(--highlight-color-main);
    text-shadow: 0 0 5px var(--highlight-color-main);
}

.icon-button {
    background: none;
    border: none;
    color: white;
    font-size: 1.2em;
    cursor: pointer;
    margin-left: 15px;
    transition: color 0.3s ease, transform 0.2s ease;
}

.icon-button:hover {
    color: var(--highlight-color-main);
    transform: scale(1.1);
}

.menu-icon {
    width: 30px;
    height: 20px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    cursor: pointer;
}

.menu-icon .bar {
    width: 100%;
    height: 3px;
    background-color: white;
    border-radius: 2px;
}

/* Sidebar Navigation */
.sidebar {
    position: fixed;
    top: 0;
    left: -300px; /* Hidden by default */
    width: 280px;
    height: 100%;
    background-color: var(--border-color-main);
    box-shadow: 5px 0 15px rgba(0, 0, 0, 0.5);
    z-index: 20;
    transition: left 0.3s ease-in-out;
    padding-top: 20px;
}

.sidebar.open {
    left: 0;
}

.sidebar-header {
    display: flex;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid var(--bg-color-darker);
    margin-bottom: 20px;
    position: relative;
}

.sidebar-header h3 {
    margin: 0 0 0 15px;
    color: var(--highlight-color-main);
    font-size: 1.4em;
    max-width: 150px; /* Prevent long names from pushing close button */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.sidebar-header .close-sidebar {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 2em;
    color: white;
    cursor: pointer;
    line-height: 1;
}

.profile-avatar-small {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: var(--highlight-color-main); /* Default for coded avatars */
    overflow: hidden;
    position: relative;
    border: 2px solid var(--highlight-color-main);
    flex-shrink: 0;
    box-shadow: 0 0 8px var(--shadow-color-strong);
    background-size: cover; /* For direct pic link */
    background-position: center; /* For direct pic link */
}
.profile-avatar-small::before {
    content: 'üë§'; /* Default large avatar */
    font-family: 'Font Awesome 6 Free'; font-weight: 900;
    font-size: 30px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--button-primary-text);
}
.profile-avatar-small[style*="background-image"]::before {
    content: none; /* Hide default emoji if image is loaded */
}


.sidebar ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.sidebar ul li {
    margin-bottom: 10px;
}

.sidebar ul li a {
    display: flex;
    align-items: center;
    padding: 12px 20px;
    color: var(--text-color-main);
    text-decoration: none;
    font-size: 1.1em;
    transition: background-color 0.3s ease, color 0.3s ease;
}

.sidebar ul li a:hover {
    background-color: var(--bg-color-main);
    color: var(--highlight-color-main);
}

/* Data Saver/Dark Mode Toggle */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 40px;
    height: 20px;
    margin-left: auto; /* Push to the right */
    flex-shrink: 0; /* Prevent shrinking */
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-switch label {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 34px;
}

.toggle-switch label:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 50%;
}

.toggle-switch input:checked + label {
    background-color: var(--highlight-color-main);
}

.toggle-switch input:checked + label:before {
    -webkit-transform: translateX(20px);
    -ms-transform: translateX(20px);
    transform: translateX(20px);
}


/* Main Content */
.main-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 80px; /* Space for bottom nav */
}

.app-screen {
    display: none;
}

.app-screen.active {
    display: block;
}

section {
    background-color: var(--bg-color-main);
    padding: 20px;
    margin-bottom: 20px;
    border-radius: 8px;
    box-shadow: 0 0 15px var(--shadow-color-main);
    border: 1px solid var(--border-color-main);
}

h2 {
    color: var(--highlight-color-main);
    text-shadow: 0 0 5px var(--highlight-color-main);
    border-bottom: 2px solid var(--border-color-main);
    padding-bottom: 10px;
    margin-bottom: 20px;
}

/* Category Filter */
.category-filter {
    margin-bottom: 20px;
}
.category-filter select {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    background-color: var(--input-bg);
    color: var(--text-color-main);
    border: 1px solid var(--input-border);
}


/* Post Feed Styles */
.posts-feed {
    display: flex;
    flex-direction: column;
    gap: 20px; /* Space between posts */
}

.post-card {
    background-color: var(--post-card-bg);
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.08);
    border: 1px solid var(--bg-color-darker);
    transition: box-shadow 0.3s ease-in-out, border-color 0.3s ease-in-out;
    position: relative; /* For neon effect */
}

.post-card.neon-glow {
    box-shadow: 0 0 5px var(--highlight-color-main), 0 0 15px var(--highlight-color-main), 0 0 25px var(--highlight-color-main), 0 0 35px var(--highlight-color-main);
    border-color: var(--highlight-color-main);
}

.post-header {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.profile-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: var(--highlight-color-main); /* Default for coded avatars */
    margin-right: 10px;
    overflow: hidden;
    position: relative;
    border: 2px solid var(--highlight-color-main);
    flex-shrink: 0;
    background-size: cover; /* For direct pic link */
    background-position: center; /* For direct pic link */
}
.profile-avatar::before {
    content: 'üë§'; /* Default placeholder emoji */
    font-family: 'Font Awesome 6 Free'; font-weight: 900;
    font-size: 24px;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: var(--button-primary-text);
}
.profile-avatar[style*="background-image"]::before {
    content: none; /* Hide default emoji if image is loaded */
}


.profile-avatar.small {
    width: 30px;
    height: 30px;
    border-width: 1px;
}

.username {
    font-weight: bold;
    color: white;
    flex-grow: 1;
    cursor: pointer;
}

.post-options {
    position: relative;
}

.post-options .fa-ellipsis-v {
    cursor: pointer;
    font-size: 1.2em;
    color: var(--text-color-light);
}

.options-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    background-color: var(--bg-color-main);
    border: 1px solid var(--border-color-main);
    border-radius: 5px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
    z-index: 5;
    min-width: 120px;
    overflow: hidden;
}

.options-dropdown span {
    display: block;
    padding: 10px 15px;
    cursor: pointer;
    color: var(--text-color-main);
    transition: background-color 0.2s ease;
}

.options-dropdown span:hover {
    background-color: var(--post-card-bg);
}

.post-content {
    margin-bottom: 10px;
}

.post-content p {
    margin: 0 0 10px 0;
    word-wrap: break-word; /* Ensure long words break */
}

.post-content img {
    max-width: 100%;
    border-radius: 8px;
    margin-top: 10px;
    border: 1px solid var(--bg-color-darker);
    display: block; /* Ensures images behave like blocks */
    margin-bottom: 10px;
}

.post-content iframe {
    width: 100%;
    aspect-ratio: 16 / 9; /* For responsive YouTube embeds */
    border-radius: 8px;
    margin-top: 10px;
    border: 1px solid var(--bg-color-darker);
    margin-bottom: 10px;
}


.post-content a {
    color: var(--highlight-color-main);
    text-decoration: underline;
    word-break: break-all;
}

.post-content b, .post-content strong {
    font-weight: bold;
}

.post-content i, .post-content em {
    font-style: italic;
}

.post-footer {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.post-actions {
    display: flex;
    align-items: center;
    gap: 20px;
}

.like-button, .views-count, .translate-button, .speaker-button, .comment-button, .repost-button {
    cursor: pointer;
    display: flex;
    align-items: center;
    color: var(--text-color-light);
    transition: color 0.2s ease;
}

.like-button i, .views-count i, .translate-button i, .speaker-button i, .comment-button i, .repost-button i {
    margin-right: 5px;
}

.like-button .fas.fa-heart {
    color: #ff007f; /* Red for liked */
    animation: bounceIn 0.3s ease-out;
}

.post-reactions {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.9em;
    color: var(--text-color-light);
}

.emoji-reaction-display {
    display: flex;
    gap: 5px;
    align-items: center;
}

.emoji-reaction-display .emoji {
    font-size: 1.2em;
    display: flex; /* To align count */
    align-items: center;
}

.emoji-reaction-display .count {
    font-size: 0.8em;
    margin-left: 2px;
    color: var(--text-color-main);
}

.total-reactions {
    margin-left: 10px;
    font-weight: bold;
    color: var(--highlight-color-main);
}

.emoji-picker, .emoji-picker-chat {
    position: absolute;
    bottom: 10px; /* Adjust based on footer position */
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--bg-color-main);
    border: 1px solid var(--border-color-main);
    border-radius: 8px;
    padding: 8px;
    display: flex;
    gap: 10px;
    box-shadow: 0 5px 20px var(--shadow-color-strong);
    z-index: 10;
}

.emoji-option {
    font-size: 1.5em;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.emoji-option:hover {
    transform: scale(1.2);
}

/* Horizontal Post Layout (for mixed feed) */
.horizontal-post-container {
    display: flex;
    overflow-x: auto;
    gap: 15px;
    padding: 10px 0;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch; /* For smoother scrolling on iOS */
    margin: 10px 0;
    background-color: var(--bg-color-darker);
    border-radius: 10px;
    padding: 15px;
    box-shadow: inset 0 0 10px var(--shadow-color-main);
    border: 1px solid var(--border-color-main);
}

.horizontal-post-container .post-card {
    min-width: 250px; /* Fixed width for horizontal items */
    scroll-snap-align: start;
    flex-shrink: 0;
    margin-bottom: 0; /* Override default margin */
}

.horizontal-post-container .post-card .post-content img {
    height: 150px; /* Fixed height for horizontal images */
    object-fit: cover;
}
.horizontal-post-container .post-card .post-content iframe {
    height: 150px; /* Fixed height for horizontal YouTube */
    object-fit: cover;
}

/* Table Post Layout */
.table-post-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Responsive grid */
    gap: 15px;
    padding: 15px;
    background-color: var(--bg-color-darker);
    border-radius: 10px;
    box-shadow: inset 0 0 10px var(--shadow-color-main);
    border: 1px solid var(--border-color-main);
    margin: 10px 0;
}

.table-post-container .post-card {
    margin-bottom: 0; /* Override default margin */
    padding: 10px;
}

.table-post-container .post-card .post-content img {
    height: 100px; /* Smaller images for table layout */
    object-fit: cover;
}
.table-post-container .post-card .post-content iframe {
    height: 100px; /* Smaller YouTube for table layout */
    object-fit: cover;
}
.table-post-container .post-card .post-content p {
    font-size: 0.85em; /* Smaller text for table layout */
    display: -webkit-box;
    -webkit-line-clamp: 3; /* Limit text to 3 lines */
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}


/* Form & Button Styles */
.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    color: var(--text-color-main);
}

input[type="text"],
input[type="email"],
input[type="password"],
input[type="file"],
textarea,
select {
    width: 100%;
    padding: 12px;
    border: 1px solid var(--input-border); /* Neon border */
    border-radius: 6px;
    background-color: var(--input-bg);
    color: var(--text-color-main);
    box-sizing: border-box;
    font-size: 1em;
    box-shadow: 0 0 8px var(--shadow-color-main);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

input[type="text"]:focus,
input[type="email"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
    border-color: var(--highlight-color-secondary); /* Pink focus */
    box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
    outline: none;
}

textarea {
    resize: vertical;
    min-height: 100px;
}

input[type="file"] {
    padding: 8px; /* Less padding for file input */
}

.btn {
    display: inline-block;
    padding: 12px 25px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1em;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    text-align: center;
    text-decoration: none; /* For link buttons */
}

.btn.primary-btn {
    background-color: var(--button-primary-bg);
    color: var(--button-primary-text);
    box-shadow: 0 0 10px var(--shadow-color-strong);
}

.btn.primary-btn:hover {
    background-color: #00e0e0;
    transform: translateY(-2px);
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
}
.btn:disabled { /* General styling for disabled buttons */
    opacity: 0.6;
    cursor: not-allowed;
    transform: translateY(0);
    box-shadow: none;
}


.btn.secondary-btn {
    background-color: var(--button-secondary-bg);
    color: var(--button-secondary-text);
    border: 1px solid var(--highlight-color-main);
}

.btn.secondary-btn:hover {
    background-color: #4a6684;
    transform: translateY(-2px);
    box-shadow: 0 0 10px var(--shadow-color-strong);
}

.btn.danger-btn {
    background-color: #e74c3c;
    color: white;
}

.btn.danger-btn:hover {
    background-color: #c0392b;
    transform: translateY(-2px);
}

.btn.social-btn {
    background-color: #2e8b57; /* WhatsApp Green */
    color: white;
    margin-right: 10px;
}

.btn.social-btn i {
    margin-right: 8px;
}

.btn.social-btn:hover {
    background-color: #226b41;
}

.profile-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 20px;
    justify-content: center;
}

.btn.tab-btn {
    background-color: var(--bg-color-darker);
    color: var(--text-color-main);
    padding: 8px 15px;
    font-size: 0.9em;
    border-radius: 5px;
    margin-right: 5px;
}

.btn.tab-btn.active {
    background-color: var(--highlight-color-main);
    color: var(--button-primary-text);
}
.profile-post-tabs {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border-color-main);
    padding-bottom: 10px;
}

/* Modals */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100;
}

.modal-content {
    background-color: var(--bg-color-main);
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 0 25px var(--shadow-color-main);
    border: 1px solid var(--highlight-color-main);
    width: 90%;
    max-width: 500px;
    position: relative;
    animation: fadeInScale 0.3s ease-out;
    max-height: 90vh; /* Allow scrolling for tall modals */
    overflow-y: auto;
}

.modal-content h3 {
    color: var(--highlight-color-main);
    margin-top: 0;
    margin-bottom: 20px;
    text-align: center;
    border-bottom: 1px solid var(--border-color-main);
    padding-bottom: 10px;
}
#profile-modal-instruction {
    color: var(--highlight-color-secondary);
    font-weight: bold;
    text-align: center;
    margin-bottom: 20px;
}


.modal-content .btn {
    margin-top: 15px;
    width: 100%;
}

.logo-options-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
    gap: 10px;
    max-height: 200px;
    overflow-y: auto;
    padding: 10px;
    border: 1px solid var(--border-color-main);
    border-radius: 8px;
    background-color: var(--bg-color-darker);
}

.logo-option-item {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: #333; /* Base color for logo previews */
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 2px solid transparent;
    transition: border-color 0.2s ease, transform 0.2s ease;
    background-size: cover; /* For direct pic link */
    background-position: center; /* For direct pic link */
}
.logo-option-item::before {
    content: 'üë§'; /* Default placeholder emoji */
    font-family: 'Font Awesome 6 Free'; font-weight: 900;
    font-size: 28px;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: var(--button-primary-text);
}
.logo-option-item.selected[style*="background-image"]::before {
    content: none; /* Hide default emoji if image is selected */
}
.logo-option-item[style*="background-image"]::before {
    content: none; /* Hide default emoji if image is present */
}


.logo-option-item.selected {
    border-color: var(--highlight-color-main);
    box-shadow: 0 0 10px var(--highlight-color-main);
}

.logo-option-item:hover {
    transform: scale(1.1);
}

/* Specific profile avatar styles for edit profile */
/* (These will be dynamically generated by JS for 50 logos) */
/* Moved to JS for dynamic insertion via style tags */


/* Profile Screen Specifics */
.profile-header-area {
    text-align: center;
    margin-bottom: 30px;
    padding: 20px;
    background-color: var(--post-card-bg);
    border-radius: 10px;
    box-shadow: 0 0 15px var(--shadow-color-main);
    border: 1px solid var(--bg-color-darker);
}

.profile-avatar-large {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background-color: var(--highlight-color-main); /* Default for coded avatars */
    margin: 0 auto 20px auto;
    overflow: hidden;
    position: relative;
    border: 4px solid var(--highlight-color-main);
    box-shadow: 0 0 15px var(--shadow-color-strong);
    background-size: cover; /* For direct pic link */
    background-position: center; /* For direct pic link */
}

.profile-avatar-large::before {
    content: 'üë§'; /* Default large avatar */
    font-size: 60px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--button-primary-text);
}
.profile-avatar-large[style*="background-image"]::before {
    content: none; /* Hide default emoji if image is loaded */
}


.profile-name {
    font-size: 1.1em;
    color: var(--text-color-light);
    margin-top: -10px;
    margin-bottom: 10px;
}
.profile-bio {
    font-size: 0.9em;
    color: var(--text-color-light);
    margin-bottom: 15px;
    max-height: 60px;
    overflow: hidden;
    text-overflow: ellipsis;
}


.profile-stats {
    display: flex;
    justify-content: center;
    gap: 25px;
    margin-top: 15px;
    font-size: 1.1em;
}

.profile-stats div {
    text-align: center;
    padding: 8px 12px;
    background-color: var(--bg-color-main);
    border-radius: 8px;
    border: 1px solid var(--highlight-color-main);
    box-shadow: 0 0 8px var(--shadow-color-main);
}

.profile-stats span {
    display: block;
    font-weight: bold;
    font-size: 1.2em;
    color: var(--highlight-color-main);
}

.clickable-stat {
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.2s ease;
}

.clickable-stat:hover {
    background-color: var(--bg-color-darker);
    transform: translateY(-2px);
}

/* Chat Styles */
.message-list-container, .chat-window-container {
    background-color: var(--post-card-bg);
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 0 15px var(--shadow-color-main);
    border: 1px solid var(--bg-color-darker);
    height: calc(100% - 40px); /* Adjust based on parent padding */
    display: flex;
    flex-direction: column;
}

.recent-chats-list {
    list-style: none;
    padding: 0;
    margin: 0;
    overflow-y: auto;
    flex-grow: 1;
}

.chat-item {
    display: flex;
    align-items: center;
    padding: 12px 10px;
    border-bottom: 1px solid var(--bg-color-main);
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.chat-item:hover {
    background-color: var(--bg-color-main);
}

.chat-info {
    margin-left: 10px;
    flex-grow: 1;
}

.chat-username {
    font-weight: bold;
    color: var(--highlight-color-main);
    display: block;
}

.last-message {
    font-size: 0.9em;
    color: var(--text-color-light);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chat-window-container {
    height: calc(100vh - 160px); /* Adjust for header/footer */
    padding: 0;
}

.chat-header {
    display: flex;
    align-items: center;
    padding: 15px;
    background-color: var(--post-card-bg);
    border-bottom: 1px solid var(--bg-color-darker);
    color: white;
}

.chat-header .icon-button {
    margin-right: 10px;
}

#chat-partner-username {
    font-size: 1.2em;
    font-weight: bold;
    color: var(--highlight-color-main);
}

.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background-color: var(--bg-color-main);
}

.message-bubble {
    padding: 10px 15px;
    border-radius: 18px;
    max-width: 80%;
    word-wrap: break-word;
    font-size: 0.95em;
    line-height: 1.4;
    position: relative; /* For emoji reaction */
}

.message-bubble.right {
    align-self: flex-end;
    background-color: var(--chat-bubble-right-bg);
    color: var(--chat-bubble-right-text);
    border-bottom-right-radius: 4px; /* Tail effect */
}

.message-bubble.left {
    align-self: flex-start;
    background-color: var(--chat-bubble-left-bg);
    color: var(--text-color-main);
    border-bottom-left-radius: 4px; /* Tail effect */
}

.chat-input-area {
    display: flex;
    padding: 10px 15px;
    border-top: 1px solid var(--bg-color-darker);
    background-color: var(--post-card-bg);
}

#message-input {
    flex-grow: 1;
    margin-right: 10px;
    min-height: 40px; /* Adjust as needed */
    max-height: 100px; /* Limit expansion */
    resize: none;
    align-self: center;
}

#send-message-btn {
    padding: 10px 15px;
    font-size: 1.2em;
}

/* Search Screen */
.search-input-group {
    display: flex;
    margin-bottom: 20px;
}

#search-query {
    flex-grow: 1;
    margin-right: 10px;
}

.search-results-container h3 {
    margin-top: 25px;
    color: var(--highlight-color-main);
    border-bottom: 1px solid var(--border-color-main);
    padding-bottom: 5px;
}

.search-list {
    list-style: none;
    padding: 0;
    margin: 0;
    background-color: var(--bg-color-darker);
    border-radius: 8px;
    border: 1px solid var(--border-color-main);
    max-height: 300px;
    overflow-y: auto;
}

.search-user-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--bg-color-main);
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.search-user-item:last-child {
    border-bottom: none;
}

.search-user-item:hover {
    background-color: var(--bg-color-main);
}

.search-username {
    flex-grow: 1;
    margin-left: 10px;
    font-weight: bold;
    color: var(--text-color-main);
}

.search-user-item .follow-btn {
    padding: 5px 10px;
    font-size: 0.9em;
}


/* Earnings Screen */
.earnings-summary {
    background-color: var(--post-card-bg);
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 0 15px var(--shadow-color-main);
    border: 1px solid var(--bg-color-darker);
    text-align: center;
}

.earnings-summary p {
    font-size: 1.1em;
    margin-bottom: 10px;
    color: var(--text-color-main);
}
.earnings-summary p span {
    font-weight: bold;
    color: var(--highlight-color-main);
    font-size: 1.2em;
}
#withdraw-btn {
    width: 100%;
    margin-top: 20px;
}
#withdrawal-status {
    margin-top: 15px;
    padding: 10px;
    border-radius: 5px;
    background-color: var(--bg-color-darker);
    text-align: center;
    color: var(--text-color-main);
    font-size: 0.9em;
}
#withdrawal-details-review {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px dashed var(--border-color-main);
}
#withdrawal-details-review h4 {
    color: var(--highlight-color-main);
    margin-bottom: 10px;
}
#withdrawal-details-review p {
    margin-bottom: 5px;
    color: var(--text-color-main);
}
#withdrawal-details-review p span {
    font-weight: bold;
    color: var(--text-color-accent);
}

/* Comments Modal */
#comments-list {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid var(--border-color-main);
    border-radius: 8px;
    padding: 10px;
    background-color: var(--bg-color-darker);
    margin-bottom: 15px;
}
.comment-item {
    padding: 8px 0;
    border-bottom: 1px dashed rgba(255,255,255,0.1);
    font-size: 0.9em;
    color: var(--text-color-main);
}
.comment-item:last-child {
    border-bottom: none;
}
.comment-item strong {
    color: var(--highlight-color-main);
}
.comment-item small {
    display: block;
    color: var(--text-color-light);
    font-size: 0.8em;
}
.comment-input-area {
    display: flex;
    margin-top: 15px;
    gap: 10px;
}
#new-comment-input {
    flex-grow: 1;
    min-height: 40px;
    max-height: 80px;
    resize: vertical;
}
#add-comment-btn {
    padding: 10px 15px;
    font-size: 1.1em;
    width: auto;
}

/* Rich Text Editor Toolbar */
.rich-text-editor .editor-toolbar {
    background-color: var(--bg-color-darker);
    border: 1px solid var(--border-color-main);
    border-radius: 6px 6px 0 0;
    padding: 8px;
    display: flex;
    gap: 5px;
}
.rich-text-editor .tool-btn {
    background: none;
    border: none;
    color: var(--text-color-main);
    font-size: 1.2em;
    padding: 5px 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background-color 0.2s ease, color 0.2s ease;
}
.rich-text-editor .tool-btn:hover {
    background-color: var(--border-color-main);
    color: var(--highlight-color-main);
}
.rich-text-editor textarea {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    border-top: none;
}
.rich-text-editor small {
    display: block;
    margin-top: 5px;
    color: var(--text-color-light);
    font-size: 0.8em;
}


/* Bottom Navigation */
.app-bottom-nav {
    display: flex;
    justify-content: space-around;
    align-items: center;
    background-color: var(--post-card-bg);
    border-top: 1px solid var(--bg-color-darker);
    padding: 10px 0;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
    position: sticky;
    bottom: 0;
    width: 100%;
    z-index: 10;
}

.nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-decoration: none;
    color: var(--text-color-light);
    font-size: 0.8em;
    transition: color 0.3s ease, transform 0.2s ease;
}

.nav-item .icon-wrapper {
    width: 30px;
    height: 30px;
    margin-bottom: 5px;
    position: relative;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 1px solid transparent; /* For active state glow */
    transition: border-color 0.3s ease;
}

/* Custom Coded Icons for Bottom Nav */
.home-icon::before { content: '\f015'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: var(--text-color-main); }
.search-icon::before { content: '\f002'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: var(--text-color-main); }
.upload-icon::before { content: '\f067'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: var(--text-color-main); } /* Plus Circle */
.messages-icon::before { content: '\f075'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: var(--text-color-main); } /* Comment Dots */
.profile-icon::before { content: '\f406'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 1.4em; color: var(--text-color-main); } /* User Circle Solid */

.nav-item.active {
    color: var(--highlight-color-main);
    transform: translateY(-3px);
}

.nav-item.active .icon-wrapper {
    border-color: var(--highlight-color-main);
    box-shadow: 0 0 10px var(--shadow-color-strong);
}

.nav-item.active .icon-wrapper::before {
    color: var(--highlight-color-main);
}


/* Ad Modal */
#ad-modal .modal-content {
    text-align: center;
}
#ad-placeholder {
    background-color: var(--bg-color-darker);
    height: 150px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 20px 0;
    border-radius: 8px;
    font-style: italic;
    color: var(--text-color-light);
    border: 1px dashed var(--highlight-color-main);
}
#close-ad-modal {
    margin-top: 20px;
}

/* Reward Popup */
.reward-content {
    text-align: center;
}
.reward-content h3 {
    color: #33ff57; /* Green for success */
    text-shadow: 0 0 8px rgba(51, 255, 87, 0.6);
    margin-bottom: 15px;
}
.reward-content i.fas.fa-trophy {
    font-size: 1.5em;
    margin-left: 10px;
    vertical-align: middle;
}
#reward-message {
    font-size: 1.1em;
    color: var(--text-color-main);
    margin-bottom: 20px;
}


/* Toast Notification */
.toast-notification {
    position: fixed;
    bottom: 80px; /* Above bottom nav */
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    z-index: 200;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    font-size: 0.95em;
    min-width: 200px;
    text-align: center;
}

.toast-notification.show {
    opacity: 1;
    visibility: visible;
}

/* Immersive Feed (Snap Scrolling) */
.immersive-feed {
    height: calc(100vh - 160px); /* Adjust height to fit screen */
    overflow-y: scroll;
    scroll-snap-type: y mandatory;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-y: contain; /* Prevents body scrolling */
    padding: 0; /* Remove padding if posts fill full width */
    margin: -20px; /* Counteract parent padding to stretch full width/height */
    width: calc(100% + 40px);
}

.immersive-feed .post-card {
    height: calc(100vh - 160px); /* Each card takes full view height */
    min-height: 400px; /* Minimum height for posts */
    scroll-snap-align: start;
    margin-bottom: 0; /* No margin between snapped items */
    border-radius: 0; /* Full screen */
    border: none;
    box-shadow: none;
    padding: 20px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    background-color: var(--bg-color-lighter); /* Keep distinct from main app background */
}

.immersive-feed .post-card .post-content {
    flex-grow: 1;
    overflow-y: auto;
    margin-top: 15px;
    margin-bottom: 15px;
}
.immersive-feed .post-card .post-content::-webkit-scrollbar {
    width: 6px;
}
.immersive-feed .post-card .post-content::-webkit-scrollbar-track {
    background: var(--bg-color-darker);
    border-radius: 10px;
}
.immersive-feed .post-card .post-content::-webkit-scrollbar-thumb {
    background: var(--highlight-color-main);
    border-radius: 10px;
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes pulse {
    0% { transform: scale(1); box-shadow: 0 0 10px rgba(0, 255, 255, 0.6), 0 0 20px rgba(255, 0, 255, 0.4); }
    100% { transform: scale(1.05); box-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 30px rgba(255, 0, 255, 0.6); }
}

@keyframes fadeInScale {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

@keyframes bounceIn {
    0% { transform: scale(0.3); opacity: 0; }
    50% { transform: scale(1.1); opacity: 1; }
    70% { transform: scale(0.9); }
    100% { transform: scale(1); }
}

/* Responsive adjustments */
@media (max-width: 600px) {
    .app-container {
        border-radius: 0;
        box-shadow: none;
        max-width: 100%;
        height: 100vh; /* Ensure it takes full height on small screens */
    }
    .auth-container {
        border-radius: 0;
        box-shadow: none;
        max-width: 100%;
        height: 100vh;
    }


    body {
        align-items: flex-start; /* Align to top on small screens */
    }

    .main-content {
        padding: 10px;
    }

    .app-header {
        padding: 10px;
    }

    .app-title {
        font-size: 1.3em;
        margin-left: 10px;
    }

    /* Status display removed from small screen overrides */

    .icon-button {
        font-size: 1em;
        margin-left: 10px;
    }

    .app-bottom-nav {
        padding: 8px 0;
    }

    .nav-item {
        font-size: 0.7em;
    }

    .nav-item .icon-wrapper {
        width: 25px;
        height: 25px;
    }

    .home-icon::before, .search-icon::before, .upload-icon::before, .messages-icon::before, .profile-icon::before {
        font-size: 1.2em;
    }

    .modal-content {
        width: 95%;
        padding: 20px;
    }

    .profile-avatar-large {
        width: 80px;
        height: 80px;
    }

    .profile-avatar-large::before {
        font-size: 45px;
    }

    .profile-stats {
        gap: 15px;
        font-size: 1em;
    }

    .profile-stats span {
        font-size: 1.1em;
    }

    .btn {
        padding: 10px 15px;
        font-size: 1em;
    }

    .profile-actions {
        flex-direction: column;
        align-items: center;
    }
    .profile-actions .btn {
        width: 80%;
    }

    .emoji-picker, .emoji-picker-chat {
        padding: 6px;
        gap: 8px;
    }

    .emoji-option {
        font-size: 1.3em;
    }

    .message-bubble {
        max-width: 90%;
    }

    .toast-notification {
        bottom: 70px;
        font-size: 0.8em;
        min-width: unset;
        width: auto;
        padding: 10px 15px;
    }

    .immersive-feed .post-card {
        padding: 15px;
        height: calc(100vh - 140px); /* Adjust height for smaller headers/footers */
    }
```

### **`script.js` (Final & Most Robust Fix for Initial Load & Black Screen)**

```javascript
// Firebase Configuration (from your input)
const firebaseConfig = {
    apiKey: "AIzaSyDlZA4grzF3fx95-11E4s7ASXwkIij1k1w",
    authDomain: "addmint-7ab6b.firebaseapp.com",
    databaseURL: "https://addmint-7ab6b-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "addmint-7ab6b",
    storageBucket: "addmint-7ab6b.firebasestorage.app",
    messagingSenderId: "504015450137",
    appId: "1:504015450137:web:694b176313582cce1e7a88",
    measurementId: "G-H7J7M23Z82"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const storage = firebase.storage();

// --- DOM Elements ---
const jsLoadIndicator = document.getElementById('js-load-indicator'); // Diagnostic element
const authContainer = document.getElementById('auth-container'); // Container for login/signup screens
const appContainer = document.getElementById('app-container'); // Main application container


// Auth Screens Elements
const loginScreen = document.getElementById('login-screen');
const signupScreen = document.getElementById('signup-screen');
const loginEmailInput = document.getElementById('login-email');
const loginPasswordInput = document.getElementById('login-password');
const loginBtn = document.getElementById('login-btn');
const loginStatus = document.getElementById('login-status');
const showSignupLink = document.getElementById('show-signup');

const signupEmailInput = document.getElementById('signup-email');
const signupPasswordInput = document.getElementById('signup-password');
const signupConfirmPasswordInput = document.getElementById('signup-confirm-password');
const signupBtn = document.getElementById('signup-btn');
const signupStatus = document.getElementById('signup-status');
const showLoginLink = document.getElementById('show-login');

const forgotPasswordLink = document.getElementById('forgot-password-link');
const forgotPasswordModal = document.getElementById('forgot-password-modal');
const resetEmailInput = document.getElementById('reset-email');
const sendResetEmailBtn = document.getElementById('send-reset-email-btn');
const resetStatus = document.getElementById('reset-status');
const closeResetModalBtn = document.getElementById('close-reset-modal');


const menuToggle = document.getElementById('menu-toggle');
const sidebar = document.getElementById('sidebar');
const closeSidebarBtn = document.getElementById('close-sidebar');
const mainContent = document.querySelector('.main-content');
const bottomNavItems = document.querySelectorAll('.app-bottom-nav .nav-item');
const screenSections = document.querySelectorAll('.app-screen');
// Coins, Credits, Limits, Gift Claim Button removed based on previous request

const refreshPostsBtn = document.getElementById('refresh-posts-btn');
const postsFeed = document.getElementById('posts-feed');
const loadingSpinner = document.getElementById('loading-spinner');


// Post Upload Screen elements
const uploadScreen = document.getElementById('upload-screen');
const postCategorySelect = document.getElementById('post-category');
const postContentInput = document.getElementById('post-content');
const postBoostSelect = document.getElementById('post-boost'); // Kept disabled for 24 hours only
const monetizePostCheckbox = document.getElementById('monetize-post-checkbox');
const publishPostBtn = document.getElementById('publish-post-btn');
const uploadStatus = document.getElementById('upload-status');
const editorToolbar = document.querySelector('.editor-toolbar');

// Profile Screen elements
const profileScreen = document.getElementById('profile-screen');
const myProfileAvatar = document.getElementById('my-profile-avatar');
const myProfileUsername = document.getElementById('my-profile-username');
const myProfileName = document.getElementById('my-profile-name');
const myProfileBio = document.getElementById('my-profile-bio');
const myPostsCount = document.getElementById('my-posts-count');
const myFollowersCount = document.getElementById('my-followers-count');
const myFollowingCount = document.getElementById('my-following-count');
const editProfileBtn = document.getElementById('edit-profile-btn');
const followUserBtn = document.getElementById('follow-user-btn');
const unfollowUserBtn = document.getElementById('unfollow-user-btn');
const messageUserBtn = document.getElementById('message-user-btn');
const profileWhatsappLink = document.getElementById('profile-whatsapp-link');
const profileInstagramLink = document.getElementById('profile-instagram-link');
const currentProfileUsernamePosts = document.getElementById('current-profile-username-posts');
const profilePostsFeed = document.getElementById('profile-posts-feed');
const profileRepostsFeed = document.getElementById('profile-reposts-feed');
const profilePostTabs = document.querySelectorAll('.profile-post-tabs .tab-btn');

const editProfileModal = document.getElementById('edit-profile-modal');
const profileModalInstruction = document.getElementById('profile-modal-instruction');
const editUsernameInput = document.getElementById('edit-username');
const usernameAvailability = document.getElementById('username-availability');
const editNameInput = document.getElementById('edit-name');
const editBioInput = document.getElementById('edit-bio');
const editWhatsappInput = document.getElementById('edit-whatsapp');
const editInstagramInput = document.getElementById('edit-instagram');
const profilePicUrlInput = document.getElementById('profile-pic-url-input');
const profileLogoOptions = document.getElementById('profile-logo-options');
const accountPrivacyToggle = document.getElementById('account-privacy-toggle');
const accountPrivacyStatus = document.getElementById('account-privacy-status');
const saveProfileBtn = document.getElementById('save-profile-btn');
const cancelEditProfileBtn = document.getElementById('cancel-edit-profile-btn');

const followListModal = document.getElementById('follow-list-modal');
const followListTitle = document.getElementById('follow-list-title');
const followListContent = document.getElementById('follow-list-content');
const closeFollowListModalBtn = document.getElementById('close-follow-list-modal');

// Messaging Screen elements
const messagesScreen = document.getElementById('messages-screen');
const messageListContainer = document.getElementById('message-list-container');
const recentChatsList = document.getElementById('recent-chats-list');
const chatWindowContainer = document.getElementById('chat-window-container');
const chatPartnerUsername = document.getElementById('chat-partner-username');
const chatPartnerAvatar = document.getElementById('chat-partner-avatar');
const chatMessages = document.getElementById('chat-messages');
const messageInput = document.getElementById('message-input');
const sendMessageBtn = document.getElementById('send-message-btn');
const backToChatsBtn = document.getElementById('back-to-chats-btn');

// Search Screen elements
const searchScreen = document.getElementById('search-screen');
const searchQueryInput = document.getElementById('search-query');
const searchBtn = document.getElementById('search-btn');
const searchUserList = document.getElementById('search-user-list');
const searchPostList = document.getElementById('search-post-list');
const noSearchResults = document.getElementById('no-search-results');

// Earnings Screen elements
const earningsScreen = document.getElementById('earnings-screen');
const totalMonetizedViewsSpan = document.getElementById('total-monetized-views');
const totalUnmonetizedViewsSpan = document.getElementById('total-unmonetized-views');
const estimatedEarningsSpan = document.getElementById('estimated-earnings');
const withdrawBtn = document.getElementById('withdraw-btn');
const withdrawalStatusDiv = document.getElementById('withdrawal-status');

const withdrawalModal = document.getElementById('withdrawal-modal');
const withdrawalViewsDisplay = document.getElementById('withdrawal-views-display');
const withdrawalMethodSelect = document.getElementById('withdrawal-method');
const withdrawalIdLabel = document.getElementById('withdrawal-id-label');
const withdrawalIdInput = document.getElementById('withdrawal-id-input');
const confirmWithdrawalBtn = document.getElementById('confirm-withdrawal-btn');
const withdrawalDetailsReview = document.getElementById('withdrawal-details-review');
const reviewMethodSpan = document.getElementById('review-method');
const reviewIdSpan = document.getElementById('review-id');
const reviewViewsSpan = document.getElementById('review-views');
const editWithdrawalBtn = document.getElementById('edit-withdrawal-btn');
const sendWithdrawalRequestBtn = document.getElementById('send-withdrawal-request-btn');
const cancelWithdrawalBtn = document.getElementById('cancel-withdrawal-btn');


// Comments Modal elements
const commentsModal = document.getElementById('comments-modal');
const commentsModalTitle = document.getElementById('comments-modal-title');
const commentsList = document.getElementById('comments-list');
const newCommentInput = document.getElementById('new-comment-input');
const addCommentBtn = document.getElementById('add-comment-btn');
const closeCommentsModalBtn = document.getElementById('close-comments-modal');

// Immersive Feed elements
const immersiveFeed = document.getElementById('immersive-feed');
const feedLoadingSpinner = document.getElementById('feed-loading-spinner');

// Sidebar user info elements
const sidebarProfileAvatar = document.getElementById('sidebar-profile-avatar');
const sidebarUsername = document.getElementById('sidebar-username');

// Dark Mode Toggle elements
const darkModeToggle = document.getElementById('dark-mode-toggle');
const darkModeCheckbox = document.getElementById('dark-mode-checkbox');
const body = document.body;
const postCategoryFilter = document.getElementById('post-category-filter');

// --- Global Variables ---
let currentUser = null; // Currently logged-in user
let currentProfileViewingId = null; // ID of the profile currently being displayed
let currentChatPartnerId = null; // ID of the user in the active chat

let lastVisiblePost = null; // For Home feed pagination
let lastVisibleImmersivePost = null; // For Immersive feed pagination

let fetchingPosts = false; // Flag to prevent multiple concurrent post fetches (Home)
let fetchingImmersivePosts = false; // Flag for Immersive feed

let postsToLoadPerScroll = 10; // Number of posts to load on scroll

let dataSaverEnabled = false; // Flag for data saver feature (logic implementation needed)
let currentPostIdForComments = null; // Stores post ID when comments modal is open

let isProcessingAuth = false; // Prevents multiple rapid authentication requests
let hasRunInitialAuthCheck = false; // Ensures the `onAuthStateChanged` block runs its full logic only once per app load cycle

let uiInitializationDone = false; // Flag to control initial UI display after Firebase SDK is ready.


// Text-to-Speech API
const synth = window.speechSynthesis;

// Profile Logo Data (50 entries)
const PROFILE_LOGOS = [
    { class: 'logo-1', emoji: 'üßë', color: '#ff6347' },
    { class: 'logo-2', emoji: 'üë©', color: '#6a5acd' },
    { class: 'logo-3', emoji: 'üöÄ', color: '#32cd32' },
    { class: 'logo-4', emoji: 'üí°', color: '#ff8c00' },
    { class: 'logo-5', emoji: 'üåü', color: '#ffd700' },
    { class: 'logo-6', emoji: 'üåà', color: '#9932cc' },
    { class: 'logo-7', emoji: 'ü¶ä', color: '#d2691e' },
    { class: 'logo-8', emoji: 'üêº', color: '#6495ed' },
    { class: 'logo-9', emoji: 'ü¶ã', color: '#dda0dd' },
    { class: 'logo-10', emoji: 'üê¢', color: '#20b2aa' },
    { class: 'logo-11', emoji: 'ü§ñ', color: '#87ceeb' },
    { class: 'logo-12', emoji: 'üëΩ', color: '#7cfc00' },
    { class: 'logo-13', emoji: 'ü¶Ñ', color: '#ee82ee' },
    { class: 'logo-14', emoji: 'üêâ', color: '#48d1cc' },
    { class: 'logo-15', emoji: 'üåä', color: '#4682b4' },
    { class: 'logo-16', emoji: 'üî•', color: '#dc143c' },
    { class: 'logo-17', emoji: 'üëë', color: '#f0e68c' },
    { class: 'logo-18', emoji: 'üíé', color: '#00ced1' },
    { class: 'logo-19', emoji: 'üîë', color: '#b0e0e6' },
    { class: 'logo-20', emoji: '‚ö°', color: '#ffff00' },
    { class: 'logo-21', emoji: 'üéµ', color: '#ff69b4' },
    { class: 'logo-22', emoji: 'üé®', color: '#7b68ee' },
    { class: 'logo-23', emoji: 'üß©', color: '#ffa07a' },
    { class: 'logo-24', emoji: 'üçî', color: '#cd853f' },
    { class: 'logo-25', emoji: 'üçï', color: '#f08080' },
    { class: 'logo-26', emoji: 'üéÆ', color: '#c0c0c0' },
    { class: 'logo-27', emoji: '‚úàÔ∏è', color: '#afeeee' },
    { class: 'logo-28', emoji: 'üå≥', color: '#228b22' },
    { class: 'logo-29', emoji: 'üå∏', color: '#ffb6c1' },
    { class: 'logo-30', emoji: '‚öΩ', color: '#b0c4de' },
    { class: 'logo-31', emoji: 'üé∏', color: '#8b4513' },
    { class: 'logo-32', emoji: 'üö≤', color: '#00fa9a' },
    { class: 'logo-33', emoji: 'üìö', color: '#deb887' },
    { class: 'logo-34', emoji: '‚òï', color: '#d2b48c' },
    { class: 'logo-35', emoji: 'üéÅ', color: '#f4a460' },
    { class: 'logo-36', emoji: 'üéâ', color: '#ba55d3' },
    { class: 'logo-37', emoji: 'üåç', color: '#87cefa' },
    { class: 'logo-38', emoji: 'üî¨', color: '#778899' },
    { class: 'logo-39', emoji: 'üî≠', color: '#696969' },
    { class: 'logo-40', emoji: 'üõ†Ô∏è', color: '#d3d3d3' },
    { class: 'logo-41', emoji: '‚öñÔ∏è', color: '#add8e6' },
    { class: 'logo-42', emoji: 'üí∞', color: '#b8860b' },
    { class: 'logo-43', emoji: 'üõ°Ô∏è', color: '#5f9ea0' },
    { class: 'logo-44', emoji: 'üîî', color: '#f0f8ff' },
    { class: 'logo-45', emoji: '‚è≥', color: '#fa8072' },
    { class: 'logo-46', emoji: 'üíæ', color: '#3cb371' },
    { class: 'logo-47', emoji: '‚öôÔ∏è', color: '#4682b4' },
    { class: 'logo-48', emoji: 'üì°', color: '#2e8b57' },
    { class: 'logo-49', emoji: 'üåê', color: '#a52a2a' },
    { class: 'logo-50', emoji: 'üìà', color: '#c71585' }
];


// --- Utility Functions ---

// Display a small toast notification on screen
function showToast(message, type = 'info', duration = 3000) {
    toastNotification.textContent = message;
    toastNotification.className = `toast-notification show ${type}`; // Add type for styling (e.g., 'error', 'success')
    setTimeout(() => {
        toastNotification.className = 'toast-notification';
    }, duration);
}

// Update authentication form status messages
function updateAuthStatus(element, message, type) {
    element.textContent = message;
    element.className = `status-message ${type}`;
    // If message is empty or hidden, set display:none for better rendering.
    if (type === 'hidden' || message === '') {
        element.style.display = 'none';
    } else {
        element.style.display = 'block'; // Or whatever is default for this status message
    }
}


// Format numbers for display (e.g., 12000 -> 12k)
function formatNumber(num) {
    if (num === undefined || num === null) return 0;
    if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
    return num;
}

// Switch between app screens (Home, Profile, etc.)
function showScreen(screenId) {
    screenSections.forEach(screen => {
        screen.classList.remove('active');
    });
    document.getElementById(screenId).classList.add('active');

    // Update active state in bottom navigation
    bottomNavItems.forEach(item => {
        if (item.dataset.screen === screenId.replace('-screen', '')) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });

    // Close sidebar if open
    sidebar.classList.remove('open');
}

// Generate a random logo class from PROFILE_LOGOS
function getRandomLogoClass() {
    const randomIndex = Math.floor(Math.random() * PROFILE_LOGOS.length);
    return PROFILE_LOGOS[randomIndex].class; // Return just the class name
}

// Get the full CSS class name for a given logo name (e.g., 'logo-1' -> 'user-logo-1')
function getLogoCssClass(logoName) {
    const logo = PROFILE_LOGOS.find(l => l.class === logoName);
    return logo ? `user-${logo.class}` : 'user-logo-1'; // Fallback to 'user-logo-1'
}

// Dynamically inject CSS for profile logos to allow pseudo-elements (emojis) and background colors
function applyLogoStyles() {
    PROFILE_LOGOS.forEach(logo => {
        if (!document.head.querySelector(`style[data-logo-class="${logo.class}"]`)) {
            const style = document.createElement('style');
            style.setAttribute('data-logo-class', logo.class);
            style.innerHTML = `
                .profile-avatar.user-${logo.class}, .profile-avatar-large.user-${logo.class}, .profile-avatar-small.user-${logo.class}, .logo-option-item.user-${logo.class} { background-color: ${logo.color}; }
                .profile-avatar.user-${logo.class}::before, .profile-avatar-large.user-${logo.class}::before, .profile-avatar-small.user-${logo.class}::before, .logo-option-item.user-${logo.class}::before { content: '${logo.emoji}'; font-size: ${logo.class.includes('large') ? '60px' : logo.class.includes('small') ? '30px' : '24px'}; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--button-primary-text); }
            `;
            document.head.appendChild(style);
        }
    });
}
applyLogoStyles(); // Call once when the script loads.


// --- Core Authentication Flow Logic ---

// Show authentication container (Login/Signup) UI
function showAuthContainerUI() {
    console.log("Entering showAuthContainerUI(). Setting auth-container display to flex.");
    appContainer.style.display = 'none'; // Hide main app
    authContainer.style.display = 'flex'; // Show auth container using flex
    authContainer.classList.remove('hidden'); // Ensure .hidden is removed
    
    loginScreen.classList.add('active'); // Default to login screen active
    signupScreen.classList.remove('active'); // Ensure signup is inactive
    console.log("UI: Authentication screens are now visible.");
}

// Show main app container (Home Feed, Profile, etc.) UI
function showAppContainerUI() {
    console.log("Entering showAppContainerUI(). Setting app-container display to flex.");
    authContainer.style.display = 'none'; // Hide auth
    appContainer.style.display = 'flex'; // Show app container using flex
    appContainer.classList.remove('hidden'); // Ensure .hidden is removed
    console.log("UI: Main App screens are now visible.");
}


// Central function to handle authentication state and UI redirection
async function checkUserAndRedirect(user) {
    console.log(`checkUserAndRedirect called. User: ${user ? user.uid : "None"}. Email Verified: ${user ? user.emailVerified : "N/A"}.`);
    
    // This `onAuthStateChanged` listener can fire multiple times. We want initial setup once.
    // If hasRunInitialAuthCheck is true AND current Firebase user matches global `currentUser` (stable state)
    // then skip re-initialization logic to prevent unnecessary re-renders.
    if (hasRunInitialAuthCheck && user === auth.currentUser) {
        console.log("checkUserAndRedirect: Already performed initial check for this state, skipping.");
        return;
    }
    hasRunInitialAuthCheck = true; // Mark as having started processing the initial auth state.

    // Immediately hide the JS load indicator once we start processing auth, as we're about to show the main UI.
    if (jsLoadIndicator) {
        jsLoadIndicator.style.display = 'none';
        console.log("Diagnostic: JavaScript load indicator hidden.");
    }

    if (user && user.emailVerified) {
        currentUser = user; // Set global current user
        console.log(`User ${user.uid} is authenticated and verified. Attempting to load user profile from Firestore.`);
        try {
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const userDoc = await userDocRef.get();
            const userData = userDoc.data();

            // Check if user document exists AND if username and name fields are properly set (not empty strings).
            if (!userDoc.exists || !userData.username || userData.username === "" || !userData.name || userData.name === "") {
                console.log("User profile incomplete (missing username/name/doc). Forcing profile setup flow.");
                showAppContainerUI(); // Display the main app container where profile modal will live.
                showScreen('profile-screen'); // Navigate to the profile tab.
                editProfileModal.classList.remove('hidden'); // Automatically open the edit profile modal.
                profileModalInstruction.textContent = "Welcome! Please complete your profile (Username and Display Name are required) to continue using the app.";
                myProfileUsername.textContent = "@NewUser"; // Temporary UI placeholders.
                sidebarUsername.textContent = "New User";
                sidebarProfileAvatar.className = `profile-avatar-small ${getLogoCssClass('logo-1')}`;
                showToast("Welcome! Please complete your profile (Username and Display Name are required).", 'info', 5000);
            } else {
                console.log("User profile is complete. Displaying main application UI.");
                loadUserProfile(currentUser.uid); // Load all user-specific data and update sidebar/header.
                showAppContainerUI(); // Display the full main app UI.
                showScreen('home-screen'); // Default to home feed.
                loadPosts(); // Start loading content for the feed.
                showToast("Logged in successfully!", 'success');
            }
        } catch (firestoreError) {
            console.error("Firebase Firestore error while loading user profile (check rules or data structure):", firestoreError);
            showToast("Error loading user profile. Please check your internet or try logging in again.", 'error', 7000);
            auth.signOut(); // Critical error here, forcing logout.
            showAuthContainerUI(); // Fallback to authentication UI.
        }
    } else { // No user is logged in (user is null) OR user is logged in but email is NOT verified
        currentUser = null; // Ensure global user object is null.
        console.log("No authenticated and verified user. Displaying Authentication UI.");
        showAuthContainerUI(); // Display Login/Register screens.

        if (user && !user.emailVerified) { // If there's a user object, but their email is unverified
            console.log(`User ${user.uid} is authenticated but email is NOT verified. Instructing user for verification.`);
            updateAuthStatus(loginStatus, "Please verify your email to continue. Check your inbox (or spam folder) for a verification link.", 'info');
            auth.signOut(); // Best practice: sign out unverified users to streamline verification flow on next login attempt.
        } else {
            console.log("No active user session found. Showing login form.");
            updateAuthStatus(loginStatus, "", 'hidden'); // Clear any previous login status messages.
        }
    }
}


// Attach the main authentication state listener to Firebase
// This listener fires whenever the user's sign-in state changes (on app load, login, logout).
auth.onAuthStateChanged(user => {
    console.log("onAuthStateChanged event fired by Firebase SDK. User status detected.");
    checkUserAndRedirect(user); // Call our central handler function.
});


// Login/Signup/Forgot Password UI interaction handlers
showSignupLink.addEventListener('click', (e) => {
    e.preventDefault();
    loginScreen.classList.remove('active');
    signupScreen.classList.add('active');
    updateAuthStatus(loginStatus, '', 'hidden'); // Clear statuses on screen switch
    updateAuthStatus(signupStatus, '', 'hidden');
    console.log("UI: Switched to Signup screen.");
});

showLoginLink.addEventListener('click', (e) => {
    e.preventDefault();
    signupScreen.classList.remove('active');
    loginScreen.classList.add('active');
    updateAuthStatus(loginStatus, '', 'hidden'); // Clear statuses on screen switch
    updateAuthStatus(signupStatus, '', 'hidden');
    console.log("UI: Switched to Login screen.");
});

forgotPasswordLink.addEventListener('click', (e) => {
    e.preventDefault();
    forgotPasswordModal.classList.remove('hidden');
    updateAuthStatus(resetStatus, '', 'hidden'); // Clear status on modal open
    resetEmailInput.value = ''; // Clear email input
    console.log("UI: Displayed Forgot Password modal.");
});

closeResetModalBtn.addEventListener('click', () => {
    forgotPasswordModal.classList.add('hidden');
    console.log("UI: Closed Forgot Password modal.");
});

loginBtn.addEventListener('click', signInUser);
signupBtn.addEventListener('click', registerUser);
sendResetEmailBtn.addEventListener('click', sendPasswordReset);


// Handle user sign-in process
async function signInUser() {
    if (isProcessingAuth) { // Prevent multiple clicks/requests if auth is already in progress.
        console.warn("Authentication process already ongoing. Please wait.");
        return;
    }
    isProcessingAuth = true; // Set flag to true.
    loginBtn.disabled = true; // Disable login button.

    const email = loginEmailInput.value.trim();
    const password = loginPasswordInput.value.trim();

    if (!email || !password) {
        updateAuthStatus(loginStatus, "Please enter both email and password.", 'error');
        isProcessingAuth = false; // Reset flag.
        loginBtn.disabled = false; // Re-enable button.
        return;
    }

    try {
        console.log(`Attempting user sign-in for: ${email}`);
        updateAuthStatus(loginStatus, "Logging in...", 'info');
        await auth.signInWithEmailAndPassword(email, password);
        // Success: The `onAuthStateChanged` listener will automatically pick this up and handle UI redirection.
        console.log("Firebase signInWithEmailAndPassword succeeded.");
        loginEmailInput.value = ''; // Clear inputs after attempt (whether success or fail).
        loginPasswordInput.value = '';
    } catch (error) {
        console.error("Firebase Sign-in error caught:", error.code, error.message);
        let errorMessage = "Login failed. Please check your email and password.";
        // Provide user-friendly error messages based on Firebase error codes.
        if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
            errorMessage = "Invalid email or password. Please try again.";
        } else if (error.code === 'auth/too-many-requests') {
            errorMessage = "Too many failed login attempts. Please try again later (rate limit).";
        } else if (error.code === 'auth/network-request-failed') {
            errorMessage = "Network error. Please check your internet connection.";
        } else if (error.code === 'auth/user-disabled') {
            errorMessage = "Your account has been disabled. Please contact support.";
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = "Invalid email format. Please check.";
        } else if (error.code === 'auth/internal-error') {
            errorMessage = "Server error during login. Please try again later.";
        }
        updateAuthStatus(loginStatus, errorMessage, 'error');
    } finally {
        isProcessingAuth = false; // Always reset the flag.
        loginBtn.disabled = false; // Always re-enable the button.
    }
}

// Handle user registration process
async function registerUser() {
    if (isProcessingAuth) { // Prevent multiple clicks/requests if auth is already in progress.
        console.warn("Authentication process already ongoing. Please wait.");
        return;
    }
    isProcessingAuth = true; // Set flag.
    signupBtn.disabled = true; // Disable signup button.

    const email = signupEmailInput.value.trim();
    const password = signupPasswordInput.value.trim();
    const confirmPassword = signupConfirmPasswordInput.value.trim();

    if (!email || !password || !confirmPassword) {
        updateAuthStatus(signupStatus, "All fields are required.", 'error');
        isProcessingAuth = false;
        signupBtn.disabled = false;
        return;
    }
    if (password.length < 6) {
        updateAuthStatus(signupStatus, "Password must be at least 6 characters long.", 'error');
        isProcessingAuth = false;
        signupBtn.disabled = false;
        return;
    }
    if (password !== confirmPassword) {
        updateAuthStatus(signupStatus, "Passwords do not match.", 'error');
        isProcessingAuth = false;
        signupBtn.disabled = false;
        return;
    }

    try {
        console.log("Attempting user registration for:", email);
        updateAuthStatus(signupStatus, "Registering user...", 'info');
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        await sendEmailVerification(userCredential.user); // Send email verification immediately.

        // Create initial user document in Firestore with placeholder data.
        await db.collection('users').doc(userCredential.user.uid).set({
            uid: userCredential.user.uid,
            email: userCredential.user.email,
            username: "", // To be set in profile edit
            name: "",     // To be set in profile edit
            bio: "",
            whatsapp: "",
            instagram: "",
            profileLogo: getRandomLogoClass(), // Assign a random default logo
            profilePicUrl: "", // Empty for direct URL
            isPrivate: false,
            followers: [],
            following: [],
            followersCount: 0,
            followingCount: 0,
            postCount: 0,
            monetizedViewsCount: 0,
            unmonetizedViewsCount: 0,
            earnedAmount: 0.00,
            reposts: [],
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log("User registered and initial profile document created. Displaying verification message.");
        updateAuthStatus(signupStatus, "Registration successful! Please verify your email.", 'success');
        signupEmailInput.value = '';
        signupPasswordInput.value = '';
        signupConfirmPasswordInput.value = '';
        // After successful registration, switch to login screen for verification instructions.
        loginScreen.classList.add('active');
        signupScreen.classList.remove('active');
        updateAuthStatus(loginStatus, "Registered! Check your inbox (or spam) to verify email, then login.", 'info');

    } catch (error) {
        console.error("Firebase Registration error caught:", error.code, error.message);
        let errorMessage = "Registration failed.";
        // Friendly error messages.
        if (error.code === 'auth/email-already-in-use') {
            errorMessage = "This email is already in use. Please log in instead.";
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = "Invalid email format. Please check.";
        } else if (error.code === 'auth/weak-password') {
            errorMessage = "Password is too weak. Please choose a stronger one (min 6 characters).";
        } else if (error.code === 'auth/network-request-failed') {
            errorMessage = "Network error during registration. Check internet connection.";
        }
        updateAuthStatus(signupStatus, errorMessage, 'error');
    } finally {
        isProcessingAuth = false; // Always reset flag.
        signupBtn.disabled = false; // Always re-enable button.
    }
}

// Send email verification link
async function sendEmailVerification(user) {
    try {
        console.log(`Sending verification email to: ${user.email}`);
        await user.sendEmailVerification();
        console.log("Verification email sent successfully.");
    } catch (error) {
        console.error("Error sending verification email:", error);
        showToast("Failed to send verification email. Please try again later.", 'error');
    }
}

// Handle password reset request
async function sendPasswordReset() {
    if (isProcessingAuth) {
        console.warn("Authentication process already ongoing.");
        return;
    }
    isProcessingAuth = true;
    sendResetEmailBtn.disabled = true; // Disable button.

    const email = resetEmailInput.value.trim();
    if (!email) {
        updateAuthStatus(resetStatus, "Please enter your email.", 'error');
        isProcessingAuth = false;
        sendResetEmailBtn.disabled = false;
        return;
    }

    try {
        console.log("Sending password reset email for:", email);
        await auth.sendPasswordResetEmail(email);
        updateAuthStatus(resetStatus, "Password reset link sent to your email! Please check your inbox.", 'success');
    } catch (error) {
        console.error("Firebase Forgot password error:", error.code, error.message);
        let errorMessage = "Failed to send reset link.";
        if (error.code === 'auth/user-not-found') {
            errorMessage = "No account found with that email address.";
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = "Invalid email format. Please check.";
        } else if (error.code === 'auth/network-request-failed') {
            errorMessage = "Network error. Check your internet connection.";
        }
        updateAuthStatus(resetStatus, errorMessage, 'error');
    } finally {
        isProcessingAuth = false;
        sendResetEmailBtn.disabled = false; // Re-enable button.
    }
}

// Handle user logout
document.getElementById('logout-btn').addEventListener('click', async () => {
    try {
        console.log("Attempting user logout.");
        await auth.signOut();
        showToast("Logged out successfully.", 'info');

        // Clear all input fields for security and a fresh start for the next user.
        loginEmailInput.value = '';
        loginPasswordInput.value = '';
        signupEmailInput.value = '';
        signupPasswordInput.value = '';
        signupConfirmPasswordInput.value = '';
        editUsernameInput.value = '';
        editNameInput.value = '';
        editBioInput.value = '';
        editWhatsappInput.value = '';
        editInstagramInput.value = '';
        profilePicUrlInput.value = '';
        
        // Reset the flag so that onAuthStateChanged will perform its full check next time.
        hasRunInitialAuthCheck = false; 

        // UI redirection will be automatically handled by the `onAuthStateChanged` listener.
        // It will detect the user as logged out and redirect to authentication screens.
    } catch (error) {
        console.error("Error during logout:", error);
        showToast("Failed to log out. Please try again.", 'error');
    }
});


// --- Initial App Load Logic (Triggered on DOMContentLoaded) ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOMContentLoaded event fired. Beginning app initialization sequence.");
    
    // 1. Initially hide both main app and authentication UI elements using CSS .hidden.
    // This prevents any "flash of unstyled content" or incorrect UI appearing before JS is ready.
    appContainer.classList.add('hidden'); 
    authContainer.classList.add('hidden'); 

    // 2. Make the `js-load-indicator` visible. This is your immediate confirmation that JS has loaded and is running.
    if (jsLoadIndicator) {
        jsLoadIndicator.style.display = 'block'; 
        console.log("Diagnostic: 'js-load-indicator' is now visible. JavaScript is running.");
    } else {
        console.warn("Diagnostic: 'js-load-indicator' element not found in DOM. Cannot confirm JS execution visually.");
    }

    // 3. Create a promise that resolves after a tiny, fixed delay (e.g., 50ms).
    // This provides a small buffer time for the browser's initial rendering and CSS application.
    const initialRenderDelayPromise = new Promise(resolve => {
        setTimeout(() => {
            console.log("Initial render delay (50ms) resolved. Proceeding to authentication check.");
            resolve(); // Fulfills the promise.
        }, 50); 
    });

    // 4. Set a final fallback timeout for authentication state resolution.
    // If Firebase SDK's `onAuthStateChanged` doesn't fire, or is too slow (e.g., due to network issues),
    // this ensures the UI still transitions after a fixed maximum delay (e.g., 2 seconds from DOMContentLoad).
    // It prevents the app from being stuck on a blank/loading screen indefinitely.
    splashScreenTimeout = setTimeout(() => {
        if (!hasRunInitialAuthCheck) { // Only if `onAuthStateChanged` handler hasn't processed its initial check.
            console.warn("Fallback: Authentication state check timed out (2s total). Forcing UI transition based on current Firebase state.");
            // Explicitly call the `checkUserAndRedirect` handler.
            // At this point, `auth.currentUser` will be either a User object or null, reflecting Firebase's best known state.
            checkUserAndRedirect(auth.currentUser);
        }
    }, 2000); // 2 seconds total max wait time.
});


// --- Data Saver Toggle Functionality ---
document.getElementById('data-saver-checkbox').addEventListener('change', (e) => {
    dataSaverEnabled = e.target.checked;
    showToast(`Data Saver ${dataSaverEnabled ? 'Enabled' : 'Disabled'}`, 'info');
    // Future enhancement: Add logic here to load lower resolution images or prioritize text over media.
});


// --- Dark Mode Toggle Functionality ---
darkModeCheckbox.addEventListener('change', (e) => {
    if (e.target.checked) {
        body.classList.add('dark-mode');
        body.classList.remove('light-mode');
        localStorage.setItem('theme', 'dark'); // Save user preference
    } else {
        body.classList.remove('dark-mode');
        body.classList.add('light-mode');
        localStorage.setItem('theme', 'light'); // Save user preference
    }
    showToast(`Dark Mode ${e.target.checked ? 'Enabled' : 'Disabled'}`, 'info');
});

// Load and apply initial theme setting from local storage.
document.addEventListener('DOMContentLoaded', () => { // Already handled within the primary DOMContentLoaded listener.
    const savedTheme = localStorage.getItem('theme') || 'dark';
    if (savedTheme === 'light') {
        body.classList.remove('dark-mode');
        body.classList.add('light-mode');
        darkModeCheckbox.checked = false;
    } else {
        body.classList.add('dark-mode');
        body.classList.remove('light-mode');
        darkModeCheckbox.checked = true;
    }
});


// --- Sidebar Navigation Control ---
menuToggle.addEventListener('click', () => {
    sidebar.classList.add('open');
});

closeSidebarBtn.addEventListener('click', () => {
    sidebar.classList.remove('open');
});

sidebar.querySelectorAll('ul li a').forEach(link => {
    link.addEventListener('click', (e) => {
        e.preventDefault();
        const screenId = e.currentTarget.dataset.screen;
        if (screenId) {
            showScreen(`${screenId}-screen`); // Switch to the selected main screen

            // Execute screen-specific loading functions
            if (screenId === 'profile') {
                loadUserProfile(currentUser.uid); // Load own profile for sidebar link
                currentProfileViewingId = currentUser.uid;
            } else if (screenId === 'messages') {
                loadRecentChats();
                messageListContainer.classList.remove('hidden');
                chatWindowContainer.classList.add('hidden'); // Ensure chat window is hidden when returning to chat list
            } else if (screenId === 'home') {
                 // On returning to home, clear feed and reload from beginning.
                 postsFeed.innerHTML = '';
                 lastVisiblePost = null;
                 loadPosts();
                 postCategoryFilter.value = 'all'; // Reset category filter
            } else if (screenId === 'feed') {
                 // On returning to immersive feed, clear feed and reload from beginning.
                 immersiveFeed.innerHTML = '';
                 lastVisibleImmersivePost = null;
                 loadImmersiveFeedPosts();
            } else if (screenId === 'earnings') {
                loadEarningsPage(); // Load earnings data.
            }
        }
        sidebar.classList.remove('open'); // Close sidebar after selection.
    });
});


// --- Bottom Navigation Control ---
bottomNavItems.forEach(item => {
    item.addEventListener('click', (e) => {
        e.preventDefault();
        const screenId = e.currentTarget.dataset.screen;
        showScreen(`${screenId}-screen`); // Switch to the selected main screen

        // Execute screen-specific loading functions (similar to sidebar)
        if (screenId === 'profile') {
            loadUserProfile(currentUser.uid);
            currentProfileViewingId = currentUser.uid;
        } else if (screenId === 'messages') {
            loadRecentChats();
            messageListContainer.classList.remove('hidden');
            chatWindowContainer.classList.add('hidden');
        } else if (screenId === 'home') {
            postsFeed.innerHTML = '';
            lastVisiblePost = null;
            loadPosts();
            postCategoryFilter.value = 'all';
        } else if (screenId === 'search') {
            searchUserList.innerHTML = ''; // Clear search results on switch
            searchPostList.innerHTML = '';
            noSearchResults.classList.add('hidden');
            searchQueryInput.value = ''; // Clear search input
        } else if (screenId === 'upload') {
            // Reset upload form inputs
            postContentInput.value = '';
            // postImageInput.value = ''; // No direct image input anymore, replaced by rich text editor.
            monetizePostCheckbox.checked = false;
            uploadStatus.textContent = '';
        }
    });
});


// --- Post Loading and Infinite Scrolling (Home Feed) ---
postCategoryFilter.addEventListener('change', () => {
    postsFeed.innerHTML = ''; // Clear posts on category change
    lastVisiblePost = null; // Reset pagination for new filter
    loadPosts(); // Reload posts
});

async function loadPosts() {
    if (!currentUser) { // Ensure logged in
        console.log("loadPosts: Skipping, no current user.");
        return;
    }
    if (fetchingPosts) { // Prevent concurrent fetches
        console.log("loadPosts: Skipping, already fetching.");
        return;
    }

    fetchingPosts = true;
    loadingSpinner.classList.remove('hidden');
    console.log("loadPosts: Starting post fetch for home feed.");

    try {
        let postsBaseRef = db.collection('posts')
                         .where('expiryTime', '>', firebase.firestore.Timestamp.now()) // Only active (not expired) posts
                         .orderBy('expiryTime', 'desc') // Newer expire dates first (effectively newer posts)
                         .orderBy('timestamp', 'desc'); // Then by creation timestamp


        const selectedCategory = postCategoryFilter.value;
        if (selectedCategory !== 'all') {
            postsBaseRef = postsBaseRef.where('category', '==', selectedCategory);
            console.log(`loadPosts: Filtering by category: ${selectedCategory}`);
        }

        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const followedUsers = userDoc.data().following || [];
        console.log(`loadPosts: Current user following ${followedUsers.length} users.`);


        let fetchedPosts = []; // Collect all posts here

        // 1. Fetch posts from followed users (chunked if more than 10 followed users)
        if (followedUsers.length > 0) {
            const chunkSize = 10; // Firestore 'in' query limit
            for (let i = 0; i < followedUsers.length; i += chunkSize) {
                const chunk = followedUsers.slice(i, i + chunkSize);
                let currentFollowedQuery = postsBaseRef.where('userId', 'in', chunk);
                
                // For combined pagination, we're not using startAfter on chunked queries directly.
                // We'll collect all, sort, and then decide what to show/paginate.
                const followedSnapshot = await currentFollowedQuery.limit(postsToLoadPerScroll * 2).get(); // Fetch a bit more to ensure variety

                followedSnapshot.docs.forEach(doc => {
                    if (!fetchedPosts.some(p => p.id === doc.id)) { // Prevent duplicates
                         fetchedPosts.push({ id: doc.id, ...doc.data() });
                    }
                });
                console.log(`loadPosts: Fetched ${followedSnapshot.size} posts from followed users chunk.`);
            }
        }

        // 2. Fetch general public posts to fill up the feed or as main content if no followed users.
        let generalPostsRef = postsBaseRef.where('isPrivate', '==', false);
        
        // If it's the very first load or if no followed posts were retrieved, use general posts for pagination.
        // If lastVisiblePost exists and fetchedPosts are few, means previous pagination hit end for followed.
        // It's very complex to paginate across multiple WHERE clauses using Firestore directly this way.
        // For 'never-ending' and complex feeds, Cloud Functions would typically pre-generate / paginate feeds.
        
        // Simpler pagination fallback for general public posts if we didn't fill up from followed.
        // This will restart pagination for general posts only.
        if (lastVisiblePost && (followedUsers.length === 0 || fetchedPosts.length < postsToLoadPerScroll)) {
             generalPostsRef = generalPostsRef.startAfter(lastVisiblePost);
             console.log("loadPosts: Adding general posts with pagination.");
        } else if (!lastVisiblePost && fetchedPosts.length === 0) {
            // First load, no followed, just general
             console.log("loadPosts: First load, only general posts.");
        } else {
             // We have enough from followed, or just mixing without deep pagination across feed types
             // To ensure some general content is always loaded along side followed:
             generalPostsRef = generalPostsRef; // No startAfter for mixed content load if not strictly paginating
        }

        const generalPostsSnapshot = await generalPostsRef.limit(postsToLoadPerScroll).get();
        generalPostsSnapshot.docs.forEach(doc => {
            if (!fetchedPosts.some(p => p.id === doc.id)) { // Avoid adding duplicates that might already be from followed.
               fetchedPosts.push({ id: doc.id, ...doc.data() });
            }
        });
        if (!generalPostsSnapshot.empty) {
            // Only update lastVisiblePost if general posts were actually added in this round of fetching
            // And they contributed to advancing the pointer.
            if (!lastVisiblePost || generalPostsSnapshot.docs[generalPostsSnapshot.docs.length - 1].id !== lastVisiblePost.id) {
                lastVisiblePost = generalPostsSnapshot.docs[generalPostsSnapshot.docs.length - 1];
            }
        }
        console.log(`loadPosts: Added ${generalPostsSnapshot.size} posts from general feed.`);


        // 3. Post-fetch processing: Filter already-displayed posts and manage 'never-ending' logic.
        const alreadyDisplayedPostIds = new Set(Array.from(postsFeed.children).map(el => el.dataset.postId));
        let newPostsToRender = fetchedPosts.filter(post => !alreadyDisplayedPostIds.has(post.id));

        console.log(`loadPosts: Total fetched posts: ${fetchedPosts.length}, new posts to render: ${newPostsToRender.length}.`);

        if (newPostsToRender.length === 0 && fetchedPosts.length > 0 && postsFeed.children.length > 0) {
            // If we fetched posts, but they were all duplicates already on screen, or no new content to add, then loop.
            showToast("No new unique posts found. Looping feed to older content...", 'info', 3000);
            lastVisiblePost = null; // Reset pagination to loop back to the start.
            console.log("loadPosts: Resetting lastVisiblePost for feed loop.");
            
            // To immediately show looping, clear and reload if we couldn't add anything.
            postsFeed.innerHTML = ''; // Clear for fresh start of looped content.
            // Recurse to load the "new-loop" content. But prevent infinite recursion if database is truly empty.
            if (postsToLoadPerScroll > 0) { // Check to prevent infinite empty calls
                 fetchingPosts = false; // Release flag for recursive call.
                 return loadPosts(); // Recursively call to get first batch of new loop.
            }

        } else if (newPostsToRender.length === 0 && postsFeed.children.length === 0) {
            // Case where NO posts at all were ever loaded initially.
            showToast("No posts available in this feed. Start by uploading one!", 'info', 5000);
            postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No posts available in this feed. Try uploading one!</p>';
            loadingSpinner.classList.add('hidden');
            fetchingPosts = false;
            return;
        } else if (newPostsToRender.length === 0) { // Fetched some, but all are already displayed AND feed is not empty. Just say nothing new.
             console.log("loadPosts: All fetched posts were already displayed.");
             showToast("No new posts at the moment.", 'info', 2000);
             loadingSpinner.classList.add('hidden');
             fetchingPosts = false;
             return;
        }


        // Clear feed only if it's explicitly the start of a full loop or initial empty state.
        if (lastVisiblePost === null && postsFeed.innerHTML.trim() !== '' && !newPostsToRender.some(p => !alreadyDisplayedPostIds.has(p.id))) {
             // This condition is for when the feed is implicitly resetting because of no new content from original order.
             postsFeed.innerHTML = ''; // Clear previous content if we are effectively starting fresh from top of looped data.
        }


        // Randomize and render the NEW posts
        let tempPostsForRendering = [...newPostsToRender];
        while (tempPostsForRendering.length > 0) {
            const randomLayout = Math.floor(Math.random() * 3); // 0: vertical, 1: horizontal, 2: table

            if (randomLayout === 0 || tempPostsForRendering.length < 4) { // Vertical or not enough for other layouts
                const post = tempPostsForRendering.shift();
                renderPost(post, postsFeed, 'vertical-post');
            } else if (randomLayout === 1 && tempPostsForRendering.length >= 2) { // Horizontal (2-3 posts)
                const numHorizontal = Math.min(tempPostsForRendering.length, Math.floor(Math.random() * 2) + 2); // 2 or 3
                const horizontalContainer = document.createElement('div');
                horizontalContainer.className = 'horizontal-post-container';
                for (let i = 0; i < numHorizontal; i++) {
                    const post = tempPostsForRendering.shift();
                    horizontalContainer.appendChild(createPostElement(post, 'horizontal-post'));
                }
                postsFeed.appendChild(horizontalContainer);
            } else if (randomLayout === 2 && tempPostsForRendering.length >= 4) { // Table (4-6 posts)
                const numTable = Math.min(postsToLoadPerScroll.length, Math.floor(Math.random() * 3) + 4); // 4, 5, or 6
                const tableContainer = document.createElement('div');
                tableContainer.className = 'table-post-container';
                for (let i = 0; i < numTable; i++) {
                    const post = tempPostsForRendering.shift();
                    tableContainer.appendChild(createPostElement(post, 'table-post'));
                }
                postsFeed.appendChild(tableContainer);
            } else { // Fallback to vertical if conditions not met
                const post = tempPostsForRendering.shift();
                renderPost(post, postsFeed, 'vertical-post');
            }
        }
        console.log(`loadPosts: Successfully rendered ${newPostsToRender.length} new posts.`);

    } catch (error) {
        console.error("Critical error loading posts for home feed:", error);
        showToast("Error loading posts. Please refresh your page or check console for details.", 'error', 7000);
    } finally {
        loadingSpinner.classList.add('hidden');
        fetchingPosts = false;
        console.log("loadPosts: Post fetching finished.");
    }
}


// Immersive Feed (Snap Scrolling) Loading Logic
async function loadImmersiveFeedPosts() {
    if (!currentUser) { // Ensure logged in
        console.log("loadImmersiveFeedPosts: Skipping, no current user.");
        return;
    }
    if (fetchingImmersivePosts) { // Prevent concurrent fetches
        console.log("loadImmersiveFeedPosts: Skipping, already fetching.");
        return;
    }

    fetchingImmersivePosts = true;
    feedLoadingSpinner.classList.remove('hidden');
    console.log("loadImmersiveFeedPosts: Starting fetch for immersive feed.");

    try {
        let postsRef = db.collection('posts')
                         .where('expiryTime', '>', firebase.firestore.Timestamp.now())
                         .where('isPrivate', '==', false) // Immersive feed only shows public posts
                         .orderBy('expiryTime', 'desc') // Newer expire dates first
                         .orderBy('timestamp', 'desc'); // Secondary sort for consistent ordering


        if (lastVisibleImmersivePost) {
            postsRef = postsRef.startAfter(lastVisibleImmersivePost);
            console.log("loadImmersiveFeedPosts: Starting after last visible post for pagination.");
        }

        const snapshot = await postsRef.limit(postsToLoadPerScroll).get();

        if (snapshot.empty) {
            console.log("loadImmersiveFeedPosts: No more posts found. Resetting for loop.");
            showToast("No more immersive posts. Looping back...", 'info', 3000);
            lastVisibleImmersivePost = null; // Reset to loop from the beginning
            fetchingImmersivePosts = false; // Release flag before recursion
            feedLoadingSpinner.classList.add('hidden');
            if (immersiveFeed.children.length === 0 || immersiveFeed.innerHTML.includes('No immersive posts available.')) {
                 immersiveFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No immersive posts available. Try uploading a public post!</p>';
                 return; // Avoid infinite recursion if DB is truly empty.
            } else {
                 immersiveFeed.innerHTML = ''; // Clear for fresh start of looped content.
                 return loadImmersiveFeedPosts(); // Recursive call to get the first batch of the new loop.
            }
        }

        lastVisibleImmersivePost = snapshot.docs[snapshot.docs.length - 1]; // Update pagination cursor

        const fetchedPosts = [];
        snapshot.docs.forEach(doc => {
            fetchedPosts.push({ id: doc.id, ...doc.data() });
        });
        console.log(`loadImmersiveFeedPosts: Fetched ${fetchedPosts.length} posts.`);

        // Filter out posts that are already displayed to avoid duplicates.
        const alreadyDisplayedImmersivePostIds = new Set(Array.from(immersiveFeed.children).map(el => el.dataset.postId));
        const newPostsToRender = fetchedPosts.filter(post => !alreadyDisplayedImmersivePostIds.has(post.id));
        
        if (newPostsToRender.length === 0 && fetchedPosts.length > 0 && immersiveFeed.children.length > 0) {
            console.log("loadImmersiveFeedPosts: Fetched posts were all duplicates, attempting loop reset.");
            // All new fetched posts were already visible and there is content. Reset and re-loop.
            showToast("No new immersive posts. Looping feed...", 'info', 3000);
            lastVisibleImmersivePost = null; // Reset pagination.
            immersiveFeed.innerHTML = ''; // Clear for fresh content.
            fetchingImmersivePosts = false;
            return loadImmersiveFeedPosts(); // Recursive call to load from the beginning.
        } else if (newPostsToRender.length === 0 && immersiveFeed.children.length === 0) {
            console.log("loadImmersiveFeedPosts: No posts fetched and feed is empty.");
            showToast("No immersive posts available. Consider uploading a public post!", 'info', 5000);
            immersiveFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No immersive posts available. Try uploading a public post!</p>';
            loadingSpinner.classList.add('hidden');
            fetchingImmersivePosts = false;
            return;
        }

        // Render posts
        newPostsToRender.forEach(post => {
            renderPost(post, immersiveFeed, 'immersive-post'); // Append directly to immersiveFeed
        });
        console.log(`loadImmersiveFeedPosts: Rendered ${newPostsToRender.length} new posts.`);


    } catch (error) {
        console.error("Critical error loading immersive feed posts:", error);
        showToast("Error loading immersive feed. Please refresh your page or check console for details.", 'error', 7000);
    } finally {
        feedLoadingSpinner.classList.add('hidden');
        fetchingImmersivePosts = false;
        console.log("loadImmersiveFeedPosts: Fetching finished.");
    }
}


function createPostElement(postData, layoutClass = 'vertical-post') {
    const postCard = document.createElement('div');
    postCard.className = `post-card ${layoutClass}`;
    postCard.dataset.postId = postData.id;
    postCard.dataset.userId = postData.userId; // Store userId on the card

    const isOwner = currentUser && postData.userId === currentUser.uid;

    let userAvatarHtml;
    if (postData.profilePicUrl) {
        // If direct picture URL is provided
        userAvatarHtml = `<div class="profile-avatar" style="background-image: url('${postData.profilePicUrl}');" data-user-id="${postData.userId}"></div>`;
    } else {
        // Fallback to emoji logo
        const userProfileClass = getLogoCssClass(postData.userProfileLogo || 'logo-1'); // Default to logo-1 if nothing defined
        userAvatarHtml = `<div class="profile-avatar ${userProfileClass}" data-user-id="${postData.userId}"></div>`;
    }


    postCard.innerHTML = `
        <div class="post-header">
            ${userAvatarHtml}
            <span class="username" data-user-id="${postData.userId}">@${postData.username || 'Unknown'}</span>
            <div class="post-options">
                <i class="fas fa-ellipsis-v"></i>
                <div class="options-dropdown hidden">
                    <span class="report-btn">Report</span>
                    <span class="repost-btn">Repost</span>
                    ${isOwner ? `<span class="delete-btn">Delete</span>` : ''}
                </div>
            </div>
        </div>
        <div class="post-content">
            ${formatPostContent(postData.content)}
        </div>
        <div class="post-footer">
            <div class="post-actions">
                <span class="like-button"><i class="far fa-heart"></i> <span class="like-count">${formatNumber(postData.likes || 0)}</span></span>
                <span class="comment-button"><i class="far fa-comment"></i> <span class="comment-count">${formatNumber(postData.commentCount || 0)}</span></span>
                <span class="views-count"><i class="fas fa-eye"></i> <span class="view-count-num">${formatNumber(postData.views || 0)}</span></span>
                <span class="speaker-button" title="Listen to Post"><i class="fas fa-volume-up"></i></span>
                <span class="translate-button" title="Translate Post"><i class="fas fa-language"></i></span>
            </div>
            <div class="post-reactions" data-post-id="${postData.id}">
                ${renderEmojiReactions(postData.reactions)}
                <span class="total-reactions">${formatNumber(Object.values(postData.reactions || {}).reduce((a, b) => a + b, 0))} reactions</span>
            </div>
        </div>
        <div class="emoji-picker hidden">
            <span class="emoji-option" data-emoji="üëç">üëç</span>
            <span class="emoji-option" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</span>
            <span class="emoji-option" data-emoji="üòÇ">üòÇ</span>
            <span class="emoji-option" data-emoji="üò¢">üò¢</span>
            <span class="emoji-option" data-emoji="üî•">üî•</span>
        </div>
    `;

    addPostEventListeners(postCard, postData);
    return postCard;
}

function renderPost(postData, container, layoutClass = 'vertical-post') {
    const postElement = createPostElement(postData, layoutClass);
    container.appendChild(postElement);
}

// Markdown-like content parsing
function formatPostContent(content) {
    if (!content) return '';

    let formattedContent = content;

    // Convert **bold**
    formattedContent = formattedContent.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
    // Convert *italic*
    formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<i>$1</i>');
    // Convert [link text](http://url.com)
    formattedContent = formattedContent.replace(/\[(.*?)\]\((https?:\/\/[^\s]+)\)/g, '<a href="$2" target="_blank">$1</a>');
    // Convert ![image alt](http://image.url)
    formattedContent = formattedContent.replace(/!\[(.*?)\]\((https?:\/\/[^\s]+(\.gif|\.jpg|\.jpeg|\.png|\.webp))\)/gi, '<img src="$2" alt="$1">');
    // Convert ![youtube video](VIDEO_ID or full url)
    formattedContent = formattedContent.replace(/!\[youtube video\]\((?:https?:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?\)/gi, '<iframe src="https://www.youtube.com/embed/$1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>');


    // Convert plain URLs to clickable links if not already handled
    const urlRegex = /(?<!["'])((https?:\/\/[^\s<>"']+)|(www\.[^\s<>"']+))(?![])]/g; // Excludes URLs inside existing links or images
    formattedContent = formattedContent.replace(urlRegex, (match) => {
        // Ensure it's not part of an existing anchor tag
        if (match.startsWith('<a') || match.includes('src=')) {
            return match;
        }
        const href = match.startsWith('http') ? match : `http://${match}`;
        return `<a href="${href}" target="_blank">${match}</a>`;
    });

    // Wrap in paragraph tags if not already HTML
    if (!formattedContent.startsWith('<p>') && !formattedContent.startsWith('<div')) {
        formattedContent = `<p>${formattedContent.split('\n').join('<br>')}</p>`;
    } else {
        formattedContent = formattedContent.split('\n').join('<br>'); // Convert newlines to <br>
    }

    return formattedContent;
}


function renderEmojiReactions(reactions) {
    if (!reactions) return '';
    const topEmojis = Object.entries(reactions)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 3);

    let html = '<span class="emoji-reaction-display">';
    topEmojis.forEach(([emoji, count]) => {
        html += `<span class="emoji">${emoji}</span><span class="count">${formatNumber(count)}</span>`;
    });
    html += '</span>';
    return html;
}

// Add event listeners for post elements
let lastClickTime = 0;
let clickTimer;
let longPressTimer;
let currentNeonPost = null;
let currentSpeechUtterance = null; // To keep track of the current speech

function addPostEventListeners(postElement, postData) {
    const postId = postData.id;
    const likeButton = postElement.querySelector('.like-button');
    const commentButton = postElement.querySelector('.comment-button');
    const speakerButton = postElement.querySelector('.speaker-button');
    const translateButton = postElement.querySelector('.translate-button');
    const postOptionsBtn = postElement.querySelector('.post-options .fa-ellipsis-v');
    const optionsDropdown = postElement.querySelector('.options-dropdown');
    const reportBtn = postElement.querySelector('.report-btn');
    const repostBtn = postElement.querySelector('.repost-btn');
    const deleteBtn = postElement.querySelector('.delete-btn');
    const profileAvatar = postElement.querySelector('.profile-avatar');
    const usernameSpan = postElement.querySelector('.username');
    const emojiPicker = postElement.querySelector('.emoji-picker');

    // Profile Click
    if (profileAvatar) {
        profileAvatar.addEventListener('click', () => openUserProfile(postData.userId));
    }
    if (usernameSpan) {
        usernameSpan.addEventListener('click', () => openUserProfile(postData.userId));
    }

    // Double-click for Like & Single Click for Neon Effect
    postElement.addEventListener('click', (e) => {
        // Exclude clicks on action buttons or dropdowns
        if (e.target.closest('.post-actions') || e.target.closest('.post-options') || e.target.closest('.emoji-picker')) {
            return;
        }

        const currentTime = new Date().getTime();
        const timeDiff = currentTime - lastClickTime;

        if (timeDiff < 300 && timeDiff > 0) { // Double click detected (within 300ms)
            clearTimeout(clickTimer);
            handleLike(postId, postElement);
            lastClickTime = 0; // Reset for next double click
        } else {
            // Single click for neon effect (unless a double click happens)
            clearTimeout(clickTimer);
            clickTimer = setTimeout(() => {
                handleNeonEffect(postElement);
            }, 300); // Wait to see if it's a double click
        }
        lastClickTime = currentTime;
    });

    // Long press for emoji reactions
    postElement.addEventListener('touchstart', (e) => {
        // Exclude actions on interactive elements
        if (e.target.closest('.post-actions') || e.target.closest('.post-options') || e.target.closest('a')) {
            return;
        }
        e.preventDefault(); // Prevent default touch behavior like scrolling
        clearTimeout(clickTimer); // Clear potential single/double click
        longPressTimer = setTimeout(() => {
            emojiPicker.classList.remove('hidden');
        }, 800); // 800ms for long press (adjust as needed)
    });

    postElement.addEventListener('touchend', () => {
        clearTimeout(longPressTimer);
    });

    // Hide emoji picker if clicking outside (simple example)
    document.addEventListener('click', (e) => {
        if (!emojiPicker.contains(e.target) && !postElement.contains(e.target)) {
            emojiPicker.classList.add('hidden');
        }
    });

    // Emoji selection
    emojiPicker.querySelectorAll('.emoji-option').forEach(emojiOption => {
        emojiOption.addEventListener('click', (e) => {
            const selectedEmoji = e.target.dataset.emoji;
            handleEmojiReaction(postId, selectedEmoji, postElement);
            emojiPicker.classList.add('hidden');
        });
    });

    // Like Button explicit click
    if (likeButton) {
        likeButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent post's general click handler
            handleLike(postId, postElement);
        });
    }

    // Comment Button
    if (commentButton) {
        commentButton.addEventListener('click', (e) => {
            e.stopPropagation();
            openCommentsModal(postId);
        });
    }

    // Speaker Button (Text-to-Speech)
    if (speakerButton) {
        speakerButton.addEventListener('click', (e) => {
            e.stopPropagation();
            handleSpeakPost(postData.content);
        });
    }

    // Translate Button
    if (translateButton) {
        translateButton.addEventListener('click', (e) => {
            e.stopPropagation();
            handleTranslatePost(postData.content);
        });
    }

    // Post Options (Report/Delete/Repost)
    if (postOptionsBtn) {
        postOptionsBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent post click/neon effect
            optionsDropdown.classList.toggle('hidden');
        });

        // Close dropdown if clicking outside
        document.addEventListener('click', (e) => {
            if (!postOptionsBtn.contains(e.target) && !optionsDropdown.contains(e.target)) {
                optionsDropdown.classList.add('hidden');
            }
        });
    }

    if (reportBtn) {
        reportBtn.addEventListener('click', () => {
            handleReportPost(postId);
            optionsDropdown.classList.add('hidden');
        });
    }

    if (repostBtn) {
        repostBtn.addEventListener('click', () => {
            handleRepost(postId);
            optionsDropdown.classList.add('hidden');
        });
    }

    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            handleDeletePost(postId, postElement, postData.isMonetized);
            optionsDropdown.classList.add('hidden');
        });
    }

    // Views count - increment on first unique view per user per session (simplified client-side)
    // Only increment if the post is currently visible in the main content area for a minimum duration
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // If it's a monetized post, start tracking view duration
                if (postData.isMonetized) {
                    postElement.viewStartTime = Date.now();
                }
                incrementViewCount(postId, postData.isMonetized);
            } else {
                // If post is monetized and scrolls out, check view duration
                if (postData.isMonetized && postElement.viewStartTime) {
                    const viewDuration = Date.now() - postElement.viewStartTime;
                    if (viewDuration >= 5000) { // 5 seconds threshold
                        incrementMonetizedView(postId); // Increment monetized view only if duration met
                    }
                    delete postElement.viewStartTime; // Reset
                }
            }
        });
    }, { threshold: 0.8 }); // Trigger when 80% of the post is visible

    observer.observe(postElement);
}

// Function to handle the neon effect
function handleNeonEffect(postElement) {
    // Remove neon from previously highlighted post
    if (currentNeonPost && currentNeonPost !== postElement) {
        currentNeonPost.classList.remove('neon-glow');
    }
    // Add neon to current post
    postElement.classList.add('neon-glow');
    currentNeonPost = postElement;

    // Remove neon after 3-4 seconds
    setTimeout(() => {
        postElement.classList.remove('neon-glow');
        if (currentNeonPost === postElement) {
            currentNeonPost = null;
        }
    }, 3500); // 3.5 seconds
}

// Like functionality
async function handleLike(postId, postElement) {
    if (!currentUser) {
        showToast("Please log in to like posts.", 'info');
        return;
    }

    const likeButtonIcon = postElement.querySelector('.like-button i');
    const likeCountSpan = postElement.querySelector('.like-button .like-count');

    try {
        const postRef = db.collection('posts').doc(postId);
        const postDoc = await postRef.get();
        if (!postDoc.exists) return;

        const postData = postDoc.data();
        const currentLikes = postData.likes || 0;
        const likedBy = postData.likedBy || [];

        let newLikes = currentLikes;
        let action = '';

        if (likedBy.includes(currentUser.uid)) {
            // Unlike
            newLikes--;
            likeButtonIcon.classList.remove('fas');
            likeButtonIcon.classList.add('far');
            action = 'remove';
        } else {
            // Like
            newLikes++;
            likeButtonIcon.classList.remove('far');
            likeButtonIcon.classList.add('fas');
            action = 'add';
        }

        await db.runTransaction(async (transaction) => {
            const updatedLikedBy = action === 'add'
                ? firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
                : firebase.firestore.FieldValue.arrayRemove(currentUser.uid);

            transaction.update(postRef, {
                likes: newLikes,
                likedBy: updatedLikedBy
            });
        });

        likeCountSpan.textContent = formatNumber(newLikes);
        showToast(action === 'add' ? "Post liked!" : "Post unliked.", 'success');

    } catch (error) {
        console.error("Error liking post:", error);
        showToast("Failed to like/unlike post. Try again.", 'error');
    }
}

// Emoji Reaction functionality
async function handleEmojiReaction(postId, emoji, postElement) {
    if (!currentUser) {
        showToast("Please log in to react to posts.", 'info');
        return;
    }

    try {
        const postRef = db.collection('posts').doc(postId);

        await db.runTransaction(async (transaction) => {
            const postDoc = await transaction.get(postRef);
            if (!postDoc.exists) {
                showToast("Post not found.", 'error');
                return;
            }

            const postData = postDoc.data();
            const currentReactions = postData.reactions || {};
            const userReactions = postData.userReactions || {}; // Tracks what each user reacted with

            const existingReaction = userReactions[currentUser.uid];

            let updatedUserReactions = { ...userReactions };
            let updatedReactionsCount = { ...currentReactions };

            if (existingReaction) {
                // If user already reacted, decrement count of old emoji
                updatedReactionsCount[existingReaction] = (updatedReactionsCount[existingReaction] || 1) - 1;
                if (updatedReactionsCount[existingReaction] <= 0) {
                    delete updatedReactionsCount[existingReaction];
                }
            }

            if (existingReaction === emoji) {
                // User clicked the same emoji again, un-react
                delete updatedUserReactions[currentUser.uid];
            } else {
                // New reaction, or changing reaction
                updatedReactionsCount[emoji] = (updatedReactionsCount[emoji] || 0) + 1;
                updatedUserReactions[currentUser.uid] = emoji;
            }

            transaction.update(postRef, {
                reactions: updatedReactionsCount,
                userReactions: updatedUserReactions // Store user specific reaction
            });
        });

        // Update UI immediately (optimistic update)
        const totalReactionsElement = postElement.querySelector('.total-reactions');
        const emojiReactionDisplayElement = postElement.querySelector('.emoji-reaction-display');

        // Re-fetch and re-render reaction display (can be optimized with local state)
        const updatedPostDoc = await postRef.get();
        const updatedPostData = updatedPostDoc.data();
        emojiReactionDisplayElement.innerHTML = renderEmojiReactions(updatedPostData.reactions);
        totalReactionsElement.textContent = `${formatNumber(Object.values(updatedPostData.reactions || {}).reduce((a, b) => a + b, 0))} reactions`;

        showToast("Emoji reaction sent!", 'success');

    } catch (error) {
        console.error("Error sending emoji reaction:", error);
        showToast("Failed to send reaction. Try again.", 'error');
    }
}


// View Count functionality (overall views)
async function incrementViewCount(postId, isMonetized) {
    if (!currentUser) return; // Only count views from logged-in users

    const viewTrackerKey = `viewed_${postId}_${currentUser.uid}`;
    // Use session storage to prevent multiple increments during a single session
    if (sessionStorage.getItem(viewTrackerKey)) {
        return; // Already viewed in this session
    }

    sessionStorage.setItem(viewTrackerKey, 'true'); // Mark as viewed for this session

    const viewsRef = db.collection('postViews').doc(postId);
    const viewCountSpan = document.querySelector(`.post-card[data-post-id="${postId}"] .view-count-num`);

    try {
        await db.runTransaction(async (transaction) => {
            const viewsDoc = await transaction.get(viewsRef);
            let viewsData = viewsDoc.exists ? viewsDoc.data() : { totalViews: 0, viewedBy: {} };
            const viewedBy = viewsData.viewedBy || {};

            if (!viewedBy[currentUser.uid]) { // Only increment if this user hasn't viewed this post ever (persistent)
                // Increment total views on the dedicated views document
                transaction.set(viewsRef, {
                    totalViews: firebase.firestore.FieldValue.increment(1),
                    [`viewedBy.${currentUser.uid}`]: true // Mark this user as having viewed it
                }, { merge: true });

                // Also increment the main post's view count
                const postRef = db.collection('posts').doc(postId);
                transaction.update(postRef, {
                    views: firebase.firestore.FieldValue.increment(1)
                });

                // Update owner's unmonetized views if not monetized
                if (!isMonetized) {
                    const postDocData = (await transaction.get(postRef)).data(); // Get latest post data within transaction
                    const postOwnerId = postDocData.userId;
                    const postOwnerRef = db.collection('users').doc(postOwnerId);
                    transaction.update(postOwnerRef, {
                        unmonetizedViewsCount: firebase.firestore.FieldValue.increment(1)
                    });
                }
            }

            if (viewCountSpan) {
                // Update UI by fetching the latest count (more reliable than optimistic for views)
                const updatedPostDoc = await db.collection('posts').doc(postId).get();
                if (updatedPostDoc.exists) {
                    viewCountSpan.textContent = formatNumber(updatedPostDoc.data().views || 0);
                }
            }
        });
    } catch (error) {
        console.error("Error incrementing view count:", error);
    }
}

// Monetized View Count (after 5-10 seconds viewing)
async function incrementMonetizedView(postId) {
    if (!currentUser) return;

    const monetizedViewTrackerKey = `monetized_viewed_${postId}_${currentUser.uid}`;
    // Use local storage for persistent tracking of monetized views per user per post
    // to prevent multiple monetized view counts for same user/post even across sessions
    if (localStorage.getItem(monetizedViewTrackerKey)) {
        return; // Already counted as a monetized view for this user
    }

    localStorage.setItem(monetizedViewTrackerKey, 'true'); // Mark as monetized viewed

    try {
        const postRef = db.collection('posts').doc(postId);
        const postDoc = await postRef.get();
        if (!postDoc.exists) return;

        const postOwnerId = postDoc.data().userId;
        const postOwnerRef = db.collection('users').doc(postOwnerId);

        await db.runTransaction(async (transaction) => {
            const postOwnerDoc = await transaction.get(postOwnerRef);
            if (!postOwnerDoc.exists) return;

            const ownerData = postOwnerDoc.data();
            const currentMonetizedViews = ownerData.monetizedViewsCount || 0;
            const currentEarnedAmount = ownerData.earnedAmount || 0;

            const earningsPerThousandViews = 0.1; // Base earnings per 1000 views (0.1$ for 1k views)
            // You can make this dynamic or more complex. For example, higher for specific categories.
            const newEarnedAmount = currentEarnedAmount + (earningsPerThousandViews / 1000);

            transaction.update(postOwnerRef, {
                monetizedViewsCount: firebase.firestore.FieldValue.increment(1),
                earnedAmount: newEarnedAmount
            });
        });
        showToast("Monetized view counted!", 'success', 1500); // Short toast
    } catch (error) {
        console.error("Error incrementing monetized view:", error);
    }
}


// Refresh Posts Button
refreshPostsBtn.addEventListener('click', () => {
    postsFeed.innerHTML = ''; // Clear current posts
    lastVisiblePost = null; // Reset pagination
    loadPosts(); // Reload posts from the beginning
    showToast("Posts feed refreshed!", 'info');
});

// Infinite Scroll Listener for Home Feed
mainContent.addEventListener('scroll', () => {
    if (mainContent.scrollTop + mainContent.clientHeight >= mainContent.scrollHeight - 200 &&
        document.getElementById('home-screen').classList.contains('active') && !fetchingPosts) {
        loadPosts();
    }
});

// Infinite Scroll Listener for Immersive Feed
immersiveFeed.addEventListener('scroll', () => {
    if (immersiveFeed.scrollTop + immersiveFeed.clientHeight >= immersiveFeed.scrollHeight - 200 &&
        document.getElementById('feed-screen').classList.contains('active') && !fetchingImmersivePosts) {
        loadImmersiveFeedPosts();
    }
});


// --- Post Upload Functionality ---
// Rich text editor toolbar actions
editorToolbar.addEventListener('click', (e) => {
    const command = e.target.closest('.tool-btn')?.dataset.command;
    if (!command) return;

    const textarea = postContentInput;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);

    let newValue = textarea.value;

    switch (command) {
        case 'bold':
            newValue = newValue.substring(0, start) + `**${selectedText}**` + newValue.substring(end);
            break;
        case 'italic':
            newValue = newValue.substring(0, start) + `*${selectedText}*` + newValue.substring(end);
            break;
        case 'insertImage':
            const imageUrl = prompt("Enter direct image URL (e.g., from imgbb.com, postimages.org):");
            if (imageUrl) {
                newValue = newValue.substring(0, start) + `![Image Description](${imageUrl})` + newValue.substring(end);
            }
            break;
        case 'insertYoutube':
            const youtubeUrl = prompt("Enter YouTube video URL or ID:");
            if (youtubeUrl) {
                newValue = newValue.substring(0, start) + `![youtube video](${youtubeUrl})` + newValue.substring(end);
            }
            break;
        case 'insertLink':
            const linkText = prompt("Enter link text:", selectedText || "Click Here");
            if (!linkText) break;
            const url = prompt("Enter URL:");
            if (url) {
                newValue = newValue.substring(0, start) + `[${linkText}](${url})` + newValue.substring(end);
            }
            break;
        default:
            break;
    }
    textarea.value = newValue;
    // Set cursor position after insertion
    textarea.selectionStart = textarea.selectionEnd = start + newValue.length - (textarea.value.length - end);
    textarea.focus();
});


publishPostBtn.addEventListener('click', async () => {
    if (!currentUser) {
        showToast("Please log in to upload posts.", 'error');
        return;
    }

    const content = postContentInput.value.trim();
    const category = postCategorySelect.value;
    const isMonetized = monetizePostCheckbox.checked;

    if (content.length < 60) {
        showToast("Post content must be at least 60 characters long.", 'error');
        return;
    }
    if (content.length > 10000) {
        showToast("Post content cannot exceed 10000 characters.", 'error');
        return;
    }

    uploadStatus.textContent = "Uploading post...";
    publishPostBtn.disabled = true;

    try {
        const userDocRef = db.collection('users').doc(currentUser.uid);
        const userDoc = await userDocRef.get();
        const userData = userDoc.data(); // Get fresh user data for username/logo


        const newPostRef = db.collection('posts').doc(); // Auto-generated ID
        const boostHours = 24; // All posts are 24 hours now

        await newPostRef.set({
            userId: currentUser.uid,
            username: userData.username, // Use user's current username
            profilePicUrl: userData.profilePicUrl || "", // User's chosen direct pic URL
            userProfileLogo: userData.profilePicUrl ? "" : (userData.profileLogo || getRandomLogoClass()), // User's chosen logo (only if no direct URL)
            content: content,
            category: category,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            likes: 0,
            views: 0,
            commentCount: 0, // Initialize comment count
            reactions: {},
            userReactions: {},
            isMonetized: isMonetized,
            isPrivate: userData.isPrivate || false, // Post inherits user's privacy setting
            expiryTime: firebase.firestore.Timestamp.fromMillis(Date.now() + (boostHours * 60 * 60 * 1000))
        });

        // Increment user's post count
        await userDocRef.update({
            postCount: firebase.firestore.FieldValue.increment(1)
        });


        uploadStatus.textContent = "Post uploaded successfully!";
        showToast("Post uploaded successfully!", 'success');
        postContentInput.value = '';
        postCategorySelect.value = 'General';
        monetizePostCheckbox.checked = false;
        showScreen('home-screen'); // Navigate back to home feed
        postsFeed.innerHTML = ''; // Clear and reload posts
        lastVisiblePost = null;
        loadPosts();

    } catch (error) {
        console.error("Error publishing post:", error);
        if (error.code === 'permission-denied' || error.message.includes('Missing or insufficient permissions')) {
            uploadStatus.textContent = "Error: Permission denied. Check Firebase rules.";
            showToast("Error publishing post: Missing or insufficient permissions. Contact admin.", 'error', 5000);
        } else {
            uploadStatus.textContent = `Error: ${error.message}`;
            showToast("Failed to upload post. Try again.", 'error');
        }
    } finally {
        publishPostBtn.disabled = false;
    }
});

// Ad Modal Logic - Still for a cost system to implement later, now gives "rewards"
let currentAdPurpose = ''; // 'message-credit', 'withdrawal-credit', 'other-benefit'
let adRewardDetails = {};

function showAdModal(purpose, details = {}) {
    currentAdPurpose = purpose;
    adRewardDetails = details;
    adModal.classList.remove('hidden');
    // For ads that provide 'costs' (which are removed from UI) these would simulate that resource.
    // For now, it will just show success.
    showToast("This app has no real 'cost' currently. Simulating benefit...", 'info', 3000);
    closeAdModalBtn.disabled = true; // Disable close until ad "finishes"

    // Simulate ad playback
    const adPlaceholder = document.getElementById('ad-placeholder');
    adPlaceholder.innerHTML = '<p>Simulating Ad (5 seconds)...</p><div class="loader"></div>';

    setTimeout(() => {
        adPlaceholder.innerHTML = '<p>Ad Complete!</p>';
        closeAdModalBtn.disabled = false;
        showToast("Ad completed! No action required now.", 'success');
    }, 5000); // Simulate 5-second ad
}

closeAdModalBtn.addEventListener('click', () => {
    adModal.classList.add('hidden');
    // Reward logic, currently no "rewards" are given as per new request.
    // But keeping structure in case a future reward/cost system is implemented.
    showRewardPopup("Ad finished. Thank you for supporting!"); // Simplified for no current reward system
});

function showRewardPopup(message) {
    // Reward Popup logic can be reused for any success messages now
    const rewardPopupEl = document.getElementById('reward-popup');
    const rewardMessageEl = document.getElementById('reward-message');
    rewardMessageEl.textContent = message;
    rewardPopupEl.classList.remove('hidden');
    document.getElementById('close-reward-popup').addEventListener('click', () => {
        rewardPopupEl.classList.add('hidden');
    }, {once: true});
}


// --- Profile Management ---
async function loadUserProfile(userId) {
    if (!userId) return;
    currentProfileViewingId = userId; // Set the ID of the profile currently being viewed

    try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
            const userData = userDoc.data();
            updateProfileDisplay(userData);
            loadProfilePosts(userId); // Load 'My Posts' by default

            // Update sidebar username and avatar
            sidebarUsername.textContent = userData.name || userData.username || "My User"; // Sidebar uses name if available
            if (userData.profilePicUrl) {
                sidebarProfileAvatar.style.backgroundImage = `url('${userData.profilePicUrl}')`;
                sidebarProfileAvatar.classList.remove('user-logo-1', 'user-logo-2'); // Clear any default emoji classes
                sidebarProfileAvatar.className = 'profile-avatar-small'; // Reset class and add direct URL style if exists
            } else {
                sidebarProfileAvatar.style.backgroundImage = 'none';
                sidebarProfileAvatar.className = `profile-avatar-small ${getLogoCssClass(userData.profileLogo || 'logo-1')}`;
            }

            // Show/hide follow/message buttons based on whose profile it is
            if (userId === currentUser.uid) {
                editProfileBtn.classList.remove('hidden');
                followUserBtn.classList.add('hidden');
                unfollowUserBtn.classList.add('hidden');
                messageUserBtn.classList.add('hidden');
                profileWhatsappLink.classList.add('hidden');
                profileInstagramLink.classList.add('hidden');
                profilePostTabs.textContent = 'My Posts';
                profilePostTabs.textContent = 'My Reposts';
            } else {
                editProfileBtn.classList.add('hidden');
                messageUserBtn.classList.remove('hidden'); // Always allow messaging
                // Check follow status
                const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
                const currentUserData = currentUserDoc.data();
                if (currentUserData.following && currentUserData.following.includes(userId)) {
                    followUserBtn.classList.add('hidden');
                    unfollowUserBtn.classList.remove('hidden');
                } else {
                    followUserBtn.classList.remove('hidden');
                    unfollowUserBtn.classList.add('hidden');
                }

                // Show social links if available
                if (userData.whatsapp) profileWhatsappLink.classList.remove('hidden'); else profileWhatsappLink.classList.add('hidden');
                if (userData.instagram) profileInstagramLink.classList.remove('hidden'); else profileInstagramLink.classList.add('hidden');

                profilePostTabs.textContent = `${userData.username}'s Posts`;
                profilePostTabs.textContent = `${userData.username}'s Reposts`;

                // If target user's account is private and current user is not following,
                // hide their posts and show a message.
                if (userData.isPrivate && !(currentUserData.following && currentUserData.following.includes(userId))) {
                    profilePostsFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">This account is private. Follow to view posts.</p>';
                    profileRepostsFeed.innerHTML = '';
                    profilePostTabs.classList.add('hidden');
                    profilePostTabs.classList.add('hidden');
                } else {
                    profilePostTabs.classList.remove('hidden');
                    profilePostTabs.classList.remove('hidden');
                }

            }
        } else {
            showToast("User profile not found.", 'error');
        }
    } catch (error) {
        console.error("Error loading user profile:", error);
        showToast("Error loading profile. Try again.", 'error');
    }
}

function updateProfileDisplay(userData) {
    const isCurrentUserProfile = currentUser && userData.uid === currentUser.uid;

    myProfileUsername.textContent = `@${userData.username || 'NewUser'}`;
    myProfileName.textContent = userData.name || '';
    myProfileBio.textContent = userData.bio || '';
    currentProfileUsernamePosts.textContent = userData.username || 'Me';

    // Handle direct picture URL or emoji logo for large avatar
    if (userData.profilePicUrl) {
        myProfileAvatar.style.backgroundImage = `url('${userData.profilePicUrl}')`;
        myProfileAvatar.classList.remove('user-logo-1', 'user-logo-2'); // Clear any default emoji classes
        myProfileAvatar.className = 'profile-avatar-large'; // Ensure only core class
    } else {
        myProfileAvatar.style.backgroundImage = 'none'; // Clear previous image
        myProfileAvatar.className = `profile-avatar-large ${getLogoCssClass(userData.profileLogo || 'logo-1')}`;
    }

    myPostsCount.textContent = formatNumber(userData.postCount || 0);
    myFollowersCount.textContent = formatNumber(userData.followersCount || 0);
    myFollowingCount.textContent = formatNumber(userData.followingCount || 0);

    if (userData.whatsapp) {
        profileWhatsappLink.href = `https://wa.me/${userData.whatsapp.replace(/\D/g, '')}`; // Remove non-digits
        profileWhatsappLink.target = '_blank';
    } else {
        profileWhatsappLink.removeAttribute('href');
    }
    if (userData.instagram) {
        profileInstagramLink.href = `https://www.instagram.com/${userData.instagram}`;
        profileInstagramLink.target = '_blank';
    } else {
        profileInstagramLink.removeAttribute('href');
    }

    if (isCurrentUserProfile) {
        editUsernameInput.value = userData.username || '';
        editNameInput.value = userData.name || '';
        editBioInput.value = userData.bio || '';
        editWhatsappInput.value = userData.whatsapp || '';
        editInstagramInput.value = userData.instagram || '';
        profilePicUrlInput.value = userData.profilePicUrl || ''; // Populate direct pic URL
        accountPrivacyToggle.checked = userData.isPrivate || false;
        accountPrivacyStatus.textContent = userData.isPrivate ? 'Private' : 'Public';
        populateProfileLogoOptions(userData.profileLogo, userData.profilePicUrl);
    }
}

// Profile Posts & Reposts Tabs
profilePostTabs.forEach(tab => {
    tab.addEventListener('click', (e) => {
        profilePostTabs.forEach(t => t.classList.remove('active'));
        e.currentTarget.classList.add('active');

        const tabType = e.currentTarget.dataset.tab;
        if (tabType === 'posts') {
            profilePostsFeed.classList.remove('hidden');
            profileRepostsFeed.classList.add('hidden');
            loadProfilePosts(currentProfileViewingId);
        } else if (tabType === 'reposts') {
            profilePostsFeed.classList.add('hidden');
            profileRepostsFeed.classList.remove('hidden');
            loadProfileReposts(currentProfileViewingId);
        }
    });
});


async function loadProfilePosts(userId) {
    profilePostsFeed.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; // Show loader
    try {
        const querySnapshot = await db.collection('posts')
            .where('userId', '==', userId)
            .where('expiryTime', '>', firebase.firestore.Timestamp.now()) // Only active posts
            .orderBy('timestamp', 'desc')
            .limit(10)
            .get();

        if (querySnapshot.empty) {
            profilePostsFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No posts yet.</p>';
            return;
        }

        profilePostsFeed.innerHTML = ''; // Clear loader
        querySnapshot.docs.forEach(doc => {
            profilePostsFeed.appendChild(createPostElement({ id: doc.id, ...doc.data() }));
        });
    } catch (error) {
        console.error("Error loading profile posts:", error);
        profilePostsFeed.innerHTML = '<p style="text-align: center; color: red;">Error loading posts.</p>';
    }
}

async function loadProfileReposts(userId) {
    profileRepostsFeed.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; // Show loader
    try {
        const userDoc = await db.collection('users').doc(userId).get();
        const userData = userDoc.data();
        const repostedPostIds = userData.reposts || [];

        if (repostedPostIds.length === 0) {
            profileRepostsFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No reposts yet.</p>';
            return;
        }

        profileRepostsFeed.innerHTML = ''; // Clear loader
        // Fetch posts by their IDs (Firestore `in` query limit is 10)
        // For more than 10, you'd need multiple queries or a Cloud Function
        // Using Promise.allSettled to handle potential missing posts gracefully
        const postPromises = repostedPostIds.slice(0, 10).map(id => db.collection('posts').doc(id).get());
        const postResults = await Promise.allSettled(postPromises);

        postResults.forEach(result => {
            if (result.status === 'fulfilled' && result.value.exists && result.value.data().expiryTime.toMillis() > Date.now()) { // Check if not expired
                profileRepostsFeed.appendChild(createPostElement({ id: result.value.id, ...result.value.data() }));
            }
        });
        if (profileRepostsFeed.innerHTML === '') {
            profileRepostsFeed.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No active reposts.</p>';
        }

    } catch (error) {
        console.error("Error loading profile reposts:", error);
        profileRepostsFeed.innerHTML = '<p style="text-align: center; color: red;">Error loading reposts.</p>';
    }
}


// Edit Profile Modal Buttons
editProfileBtn.addEventListener('click', () => {
    editProfileModal.classList.remove('hidden');
    profileModalInstruction.textContent = "Edit your profile details:"; // General instruction when clicking 'Edit Profile'
    console.log("UI: Displayed Edit Profile modal.");
});

cancelEditProfileBtn.addEventListener('click', () => {
    editProfileModal.classList.add('hidden');
    console.log("UI: Closed Edit Profile modal.");
});

// Username Availability Check
let usernameCheckTimeout;
editUsernameInput.addEventListener('input', () => {
    clearTimeout(usernameCheckTimeout);
    usernameAvailability.textContent = ''; // Clear previous status
    usernameAvailability.className = '';

    const newUsername = editUsernameInput.value.trim();
    if (newUsername === '') {
        usernameAvailability.textContent = 'Username cannot be empty.';
        usernameAvailability.classList.add('error-text');
        return;
    }

    // Get current username from logged-in user's data for comparison
    let currentAuthUsername = (currentUser && currentUser.email) ? currentUser.email.split('@') : "";
    if(myProfileUsername && myProfileUsername.textContent) {
        currentAuthUsername = myProfileUsername.textContent.replace('@', '');
    }

    if (newUsername === currentAuthUsername) {
        usernameAvailability.textContent = 'Username is available.';
        usernameAvailability.classList.add('success-text');
        return;
    }
     if (newUsername.includes(" ") || newUsername.includes("@") || newUsername.includes("#")) {
        usernameAvailability.textContent = "Username cannot contain spaces or special characters.";
        usernameAvailability.classList.add('error-text');
        return;
    }


    usernameCheckTimeout = setTimeout(async () => {
        try {
            const usersRef = db.collection('users');
            const snapshot = await usersRef.where('username', '==', newUsername).limit(1).get();

            if (snapshot.empty) {
                usernameAvailability.textContent = 'Username is available.';
                usernameAvailability.classList.add('success-text');
            } else {
                usernameAvailability.textContent = 'Username already taken.';
                usernameAvailability.classList.add('error-text');
            }
        } catch (error) {
            console.error("Error checking username availability:", error);
            usernameAvailability.textContent = 'Error checking username.';
            usernameAvailability.classList.add('error-text');
        }
    }, 500); // Debounce
});

// Privacy Toggle Status
accountPrivacyToggle.addEventListener('change', () => {
    accountPrivacyStatus.textContent = accountPrivacyToggle.checked ? 'Private' : 'Public';
});

// Populate Profile Logo Options (Now includes direct URL for selection display)
function populateProfileLogoOptions(currentLogoClass, currentProfilePicUrl) {
    profileLogoOptions.innerHTML = '';

    // If current user has a direct URL pic
    if (currentProfilePicUrl) {
        const directUrlOptionDiv = document.createElement('div');
        directUrlOptionDiv.className = `logo-option-item selected`; // Default selected
        directUrlOptionDiv.style.backgroundImage = `url('${currentProfilePicUrl}')`;
        directUrlOptionDiv.dataset.type = 'url';
        directUrlOptionDiv.dataset.value = currentProfilePicUrl;
        profileLogoOptions.appendChild(directUrlOptionDiv);
    }


    PROFILE_LOGOS.forEach(logo => {
        const logoItem = document.createElement('div');
        logoItem.className = `logo-option-item user-${logo.class}`;
        logoItem.dataset.type = 'emoji';
        logoItem.dataset.value = logo.class;

        // Select the emoji if it matches the currentLogoClass AND there is NO profilePicUrl
        if (!currentProfilePicUrl && currentLogoClass === logo.class) {
            logoItem.classList.add('selected');
        }
        // If currentProfilePicUrl exists, no emoji will be selected initially.


        logoItem.addEventListener('click', () => {
            profileLogoOptions.querySelectorAll('.logo-option-item').forEach(item => item.classList.remove('selected'));
            profilePicUrlInput.value = ''; // Clear direct URL input if an emoji is chosen
            logoItem.classList.add('selected');
        });
        profileLogoOptions.appendChild(logoItem);
    });

    // Handle clearing selection if user inputs direct URL after selecting an emoji
    profilePicUrlInput.addEventListener('input', () => {
        if (profilePicUrlInput.value.trim() !== '') {
            profileLogoOptions.querySelectorAll('.logo-option-item').forEach(item => item.classList.remove('selected'));
        }
    });

}

// Save Profile Changes
saveProfileBtn.addEventListener('click', async () => {
    if (!currentUser) return;

    const newUsername = editUsernameInput.value.trim();
    const newName = editNameInput.value.trim();
    const newBio = editBioInput.value.trim();
    const newWhatsapp = editWhatsappInput.value.trim();
    const newInstagram = editInstagramInput.value.trim();
    const newProfilePicUrl = profilePicUrlInput.value.trim(); // Get direct URL

    let finalProfilePicUrl = newProfilePicUrl; // Start with user-inputted URL
    let newProfileLogo = ''; // Initialize emoji logo to empty

    const selectedLogoElement = profileLogoOptions.querySelector('.logo-option-item.selected');

    if (finalProfilePicUrl) {
        // User entered a URL in the text field, this takes precedence
        newProfileLogo = ""; // Ensure emoji logo is empty if direct URL is present
    } else if (selectedLogoElement && selectedLogoElement.dataset.type === 'emoji') {
        // No direct URL, but an emoji logo is selected
        finalProfilePicUrl = ""; // Ensure direct URL is empty
        newProfileLogo = selectedLogoElement.dataset.value;
    } else {
        // Neither direct URL nor explicit emoji selected, use default 'logo-1'
        newProfileLogo = 'logo-1';
        finalProfilePicUrl = "";
    }


    const isPrivate = accountPrivacyToggle.checked;

    if (newUsername === '') {
        showToast("Username cannot be empty.", 'error');
        return;
    }
     if (newUsername.includes(" ") || newUsername.includes("@") || newUsername.includes("#")) {
        showToast("Username cannot contain spaces or special characters like @ or #.", "error");
        return;
    }

    // Name must be provided if it's currently empty, especially for new registrations
    const userDocRef = db.collection('users').doc(currentUser.uid);
    const userDoc = await userDocRef.get();
    const currentData = userDoc.data();
    
    if (currentData && (currentData.username === "" || currentData.name === "") && newName.length < 1) { // If it's first time profile fill and name is empty
         showToast("Display Name cannot be empty during initial profile setup.", 'error');
         return;
    }


    try {
        await userDocRef.update({
            username: newUsername,
            name: newName,
            bio: newBio,
            whatsapp: newWhatsapp,
            instagram: newInstagram,
            profileLogo: newProfileLogo,
            profilePicUrl: finalProfilePicUrl, // Save direct URL
            isPrivate: isPrivate,
            // Initialize earning/follower counts if they don't exist (important for new users saving profile for first time)
            // If they already exist, Firebase update will merge and use existing values.
            // These lines ensure values are set for NEWLY CREATED documents through initial registration flow.
            followersCount: currentData.followersCount !== undefined ? currentData.followersCount : 0,
            followingCount: currentData.followingCount !== undefined ? currentData.followingCount : 0,
            postCount: currentData.postCount !== undefined ? currentData.postCount : 0,
            monetizedViewsCount: currentData.monetizedViewsCount !== undefined ? currentData.monetizedViewsCount : 0,
            unmonetizedViewsCount: currentData.unmonetizedViewsCount !== undefined ? currentData.unmonetizedViewsCount : 0,
            earnedAmount: currentData.earnedAmount !== undefined ? currentData.earnedAmount : 0.00,
            reposts: currentData.reposts !== undefined ? currentData.reposts : []
        });

        // Update username and profile info in existing posts if changed (requires write permissions on posts too)
        if (newUsername !== (currentData.username || '') || finalProfilePicUrl !== (currentData.profilePicUrl || '') || newProfileLogo !== (currentData.profileLogo || '') || isPrivate !== currentData.isPrivate) {
            console.log("Updating username/profile info on posts via batch...");
            const postsSnapshot = await db.collection('posts').where('userId', '==', currentUser.uid).get();
            const batch = db.batch();
            postsSnapshot.docs.forEach(doc => {
                const postRef = db.collection('posts').doc(doc.id);
                batch.update(postRef, {
                    username: newUsername,
                    profilePicUrl: finalProfilePicUrl,
                    userProfileLogo: finalProfilePicUrl ? "" : newProfileLogo, // Only use emoji if no direct pic URL
                    isPrivate: isPrivate // Propagate post's privacy if user's overall privacy changed
                });
            });
            await batch.commit();
            console.log("Post updates batch committed successfully.");
        }

        editProfileModal.classList.add('hidden'); // This will now correctly hide the modal on save
        showToast("Profile updated successfully!", 'success');
        loadUserProfile(currentUser.uid); // Reload profile display
    } catch (error) {
        console.error("Error saving profile:", error);
        showToast("Failed to save profile. Please try again. Error: " + (error.message || 'Unknown error'), 'error', 6000);
    }
});

// Follow/Unfollow Logic
followUserBtn.addEventListener('click', () => handleFollow(currentProfileViewingId));
unfollowUserBtn.addEventListener('click', () => handleUnfollow(currentProfileViewingId));

async function handleFollow(targetUserId) {
    if (!currentUser) {
        showToast("Please log in to follow users.", 'info');
        return;
    }
    if (currentUser.uid === targetUserId) {
        showToast("Cannot follow yourself.", 'info');
        return;
    }

    try {
        const currentUserRef = db.collection('users').doc(currentUser.uid);
        const targetUserRef = db.collection('users').doc(targetUserId);

        await db.runTransaction(async (transaction) => {
            const currentUserDoc = await transaction.get(currentUserRef);
            const targetUserDoc = await transaction.get(targetUserRef);

            if (!currentUserDoc.exists || !targetUserDoc.exists) {
                throw new Error("User document not found during follow operation.");
            }

            const currentUserData = currentUserDoc.data();
            const targetUserData = targetUserDoc.data();

            if (currentUserData.following && currentUserData.following.includes(targetUserId)) {
                showToast("Already following this user.", 'info');
                return; // Exit transaction if already following.
            }

            // If target user is private, cannot follow directly. Need a request system.
            if (targetUserData.isPrivate) {
                showToast("This account is private. Cannot follow directly.", 'info', 4000);
                throw new Error("Private account, direct follow not allowed."); // Abort transaction.
            }

            // Perform the follow updates in the transaction.
            transaction.update(currentUserRef, {
                following: firebase.firestore.FieldValue.arrayUnion(targetUserId),
                followingCount: firebase.firestore.FieldValue.increment(1)
            });
            transaction.update(targetUserRef, {
                followers: firebase.firestore.FieldValue.arrayUnion(currentUser.uid),
                followersCount: firebase.firestore.FieldValue.increment(1)
            });
        });

        showToast(`Successfully followed @${currentProfileUsername.textContent.replace('@','')}`, 'success');
        followUserBtn.classList.add('hidden');
        unfollowUserBtn.classList.remove('hidden');
        loadUserProfile(currentProfileViewingId); // Refresh profile display to show updated counts.
    } catch (error) {
        console.error("Error following user:", error);
        if (error.message && error.message.includes("Private account")) {
             // Toast already handled by explicit throw above.
        } else {
            showToast(`Failed to follow: ${error.message || 'Unknown error'}`, 'error');
        }
    }
}

async function handleUnfollow(targetUserId) {
    if (!currentUser) {
        showToast("Please log in to unfollow users.", 'info');
        return;
    }
    if (currentUser.uid === targetUserId) {
        showToast("Cannot unfollow yourself.", 'info');
        return;
    }

    try {
        const currentUserRef = db.collection('users').doc(currentUser.uid);
        const targetUserRef = db.collection('users').doc(targetUserId);

        await db.runTransaction(async (transaction) => {
            const currentUserDoc = await transaction.get(currentUserRef);
            const targetUserDoc = await transaction.get(targetUserRef);

            if (!currentUserDoc.exists || !targetUserDoc.exists) {
                throw new Error("User document not found during unfollow operation.");
            }

            const currentUserData = currentUserDoc.data();
            // Check if this person is indeed a follower.
            if (!currentUserData.following || !currentUserData.following.includes(targetUserId)) {
                showToast("Not currently following this user.", 'info');
                return; // Exit transaction if not already following.
            }

            // Perform unfollow updates.
            transaction.update(currentUserRef, {
                following: firebase.firestore.FieldValue.arrayRemove(targetUserId),
                followingCount: firebase.firestore.FieldValue.increment(-1)
            });
            transaction.update(targetUserRef, {
                followers: firebase.firestore.FieldValue.arrayRemove(currentUser.uid),
                followersCount: firebase.firestore.FieldValue.increment(-1)
            });
        });

        showToast(`Successfully unfollowed @${currentProfileUsername.textContent.replace('@','')}`, 'success');
        followUserBtn.classList.remove('hidden');
        unfollowUserBtn.classList.add('hidden');
        loadUserProfile(currentProfileViewingId); // Refresh profile display to show updated counts.
    } catch (error) {
        console.error("Error unfollowing user:", error);
        showToast(`Failed to unfollow: ${error.message || 'Unknown error'}`, 'error');
    }
}


// Remove a follower (only if you are the user being unfollowed)
async function removeFollower(followerId) {
    if (!currentUser) {
        showToast("Please log in.", 'info');
        return;
    }

    try {
        const currentUserRef = db.collection('users').doc(currentUser.uid);
        const followerUserRef = db.collection('users').doc(followerId);

        await db.runTransaction(async (transaction) => {
            const currentUserDoc = await transaction.get(currentUserRef);
            const followerUserDoc = await transaction.get(followerUserRef);

            if (!currentUserDoc.exists || !followerUserDoc.exists) {
                throw new Error("User document not found.");
            }

            const currentUserData = currentUserDoc.data();
            // Check if this person is indeed a follower.
            if (!currentUserData.followers || !currentUserData.followers.includes(followerId)) {
                showToast("This user is not currently your follower.", 'info');
                return;
            }

            // Remove from current user's followers list.
            transaction.update(currentUserRef, {
                followers: firebase.firestore.FieldValue.arrayRemove(followerId),
                followersCount: firebase.firestore.FieldValue.increment(-1)
            });
            // Also update the removed follower's following list (remove current user from it).
            transaction.update(followerUserRef, {
                following: firebase.firestore.FieldValue.arrayRemove(currentUser.uid),
                followingCount: firebase.firestore.FieldValue.increment(-1)
            });
        });

        showToast("Follower removed successfully.", 'success');
        // Refresh the follow list modal if it's currently displaying followers.
        if (!followListModal.classList.contains('hidden') && followListTitle.textContent === 'Followers') {
            showFollowList(currentUser.uid, 'followers');
        }
        loadUserProfile(currentUser.uid); // Refresh profile counts.
    } catch (error) {
        console.error("Error removing follower:", error);
        showToast(`Failed to remove follower: ${error.message || 'Unknown error'}`, 'error');
    }
}


// Display followers/following lists in a modal
document.querySelectorAll('.clickable-stat').forEach(stat => {
    stat.addEventListener('click', (e) => {
        const statType = e.currentTarget.dataset.stat; // 'followers' or 'following'
        const userId = currentProfileViewingId; // Use the ID of the user whose profile is currently open
        if (userId) {
            showFollowList(userId, statType);
        }
    });
});

async function showFollowList(userId, type) {
    if (!currentUser) {
        showToast("Please log in to view this list.", 'info');
        return;
    }

    followListContent.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; // Show loader
    followListTitle.textContent = type === 'followers' ? 'Followers' : 'Following';
    followListModal.classList.remove('hidden'); // Show modal

    try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (!userDoc.exists) {
            followListContent.innerHTML = '<p style="text-align: center;">User not found.</p>';
            return;
        }

        const userRefs = userDoc.data()[type] || []; // Get array of UIDs for followers or following.
        if (userRefs.length === 0) {
            followListContent.innerHTML = `<p style="text-align: center;">No ${type} found.</p>`;
            return;
        }

        const usersData = [];
        // Fetch details for each user in the list (Firestore 'in' query limited to 10. Handle larger lists in batches).
        // For simplicity, here we'll just fetch first 10-20 to display.
        const fetchedUserDocs = await Promise.all(userRefs.slice(0, 20).map(id => db.collection('users').doc(id).get()));

        fetchedUserDocs.forEach(doc => {
            if (doc.exists) {
                usersData.push({ id: doc.id, ...doc.data() });
            }
        });

        usersData.sort((a,b) => (a.username || '').localeCompare(b.username || '')); // Sort display by username.


        followListContent.innerHTML = ''; // Clear loader and content.
        for (const user of usersData) { // Iterate over fetched user data to build list.
            const userItem = document.createElement('li');
            userItem.className = 'search-user-item';
            userItem.dataset.userId = user.id;

            // Determine user avatar (direct URL vs. emoji logo)
            let userAvatarHtml;
            if (user.profilePicUrl) {
                userAvatarHtml = `<div class="profile-avatar small" style="background-image: url('${user.profilePicUrl}');"></div>`;
            } else {
                const userLogoClass = getLogoCssClass(user.profileLogo || 'logo-1');
                userAvatarHtml = `<div class="profile-avatar small ${userLogoClass}"></div>`;
            }

            userItem.innerHTML = `
                ${userAvatarHtml}
                <span class="search-username">@${user.username || 'Unknown'}</span>
                <button class="btn small primary-btn follow-btn" data-target-id="${user.id}"></button>
            `;
            followListContent.appendChild(userItem);

            const actionBtn = userItem.querySelector('.follow-btn');
            // Logic to determine button text and action ('Follow', 'Following', 'Remove').
            if (currentUser.uid === user.id) { // Hide button if it's current user's profile.
                actionBtn.classList.add('hidden');
            } else if (type === 'followers' && userId === currentUser.uid) { // If viewing own followers list.
                actionBtn.textContent = 'Remove';
                actionBtn.classList.add('danger-btn');
                actionBtn.classList.remove('primary-btn');
                actionBtn.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent opening profile when clicking button.
                    await removeFollower(user.id);
                });
            } else { // For other users in the list, determine follow/unfollow status.
                const currentUserFollowingDoc = await db.collection('users').doc(currentUser.uid).get();
                const followingList = currentUserFollowingDoc.data().following || [];
                if (followingList.includes(user.id)) {
                    actionBtn.textContent = 'Following';
                    actionBtn.classList.add('secondary-btn');
                    actionBtn.classList.remove('primary-btn');
                } else {
                    actionBtn.textContent = 'Follow';
                    actionBtn.classList.add('primary-btn');
                    actionBtn.classList.remove('secondary-btn');
                }
                actionBtn.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent opening profile when clicking button.
                    const targetId = e.target.dataset.targetId;
                    if (e.target.textContent === 'Follow') {
                        await handleFollow(targetId);
                        // Update button text/style without full list reload for performance.
                        e.target.textContent = 'Following';
                        e.target.classList.add('secondary-btn');
                        e.target.classList.remove('primary-btn');
                    } else {
                        await handleUnfollow(targetId);
                        e.target.textContent = 'Follow';
                        e.target.classList.add('primary-btn');
                        e.target.classList.remove('secondary-btn');
                    }
                });
            }

            // Make the entire list item clickable to open the user's profile.
            userItem.addEventListener('click', () => {
                followListModal.classList.add('hidden'); // Close current modal.
                openUserProfile(user.id); // Navigate to clicked user's profile.
            });
        }
    } catch (error) {
        console.error("Error loading follow list:", error);
        followListContent.innerHTML = '<p style="text-align: center; color: red;">Error loading list.</p>';
        showToast("Error loading follow list.", 'error');
    }
}

closeFollowListModalBtn.addEventListener('click', () => {
    followListModal.classList.add('hidden');
});

// Navigate to another user's profile (or own if userId matches)
function openUserProfile(userId) {
    if (userId === currentUser.uid) {
        showScreen('profile-screen'); // If clicking on own profile, just navigate.
        loadUserProfile(currentUser.uid); // Load own profile data.
    } else {
        showScreen('profile-screen'); // Go to profile screen to display others' profile.
        loadUserProfile(userId); // Load data for the specified user ID.
    }
}

// --- Messaging Feature ---
messageUserBtn.addEventListener('click', () => {
    if (!currentUser || !currentProfileViewingId) {
        showToast("Select a user to message or log in first.", 'info');
        return;
    }
    openChatWindow(currentProfileViewingId);
});

async function loadRecentChats() {
    if (!currentUser) return;
    recentChatsList.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>';

    try {
        // Real-time listener for messages involving the current user to display recent chats.
        // It fetches messages where the current user is either the sender or receiver,
        // ordered by timestamp to get the latest conversations.
        db.collection('messages')
            .where('participants', 'array-contains', currentUser.uid)
            .orderBy('timestamp', 'desc')
            .onSnapshot(async (snapshot) => {
                const updatedChats = {}; // To store unique chat partners with their latest message.
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    let partnerId;
                    // Determine the other participant's ID.
                    if (data.senderId === currentUser.uid) {
                        partnerId = data.receiverId;
                    } else {
                        partnerId = data.senderId;
                    }

                    // Keep only the latest message for each chat partner.
                    // This handles potential multiple messages from same partner, keeps only the newest.
                    if (!updatedChats[partnerId] || data.timestamp.toMillis() > updatedChats[partnerId].timestamp) {
                        updatedChats[partnerId] = {
                            partnerId: partnerId,
                            lastMessage: data.content,
                            timestamp: data.timestamp.toMillis()
                        };
                    }
                });

                // Sort chat partners by their latest message timestamp.
                const chatPartners = Object.values(updatedChats).sort((a, b) => b.timestamp - a.timestamp);

                if (chatPartners.length === 0) {
                    recentChatsList.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No recent chats.</p>';
                    return;
                }

                recentChatsList.innerHTML = ''; // Clear previous chat list.
                // Fetch and display details for each chat partner.
                for (const chat of chatPartners) {
                    const partnerDoc = await db.collection('users').doc(chat.partnerId).get();
                    if (partnerDoc.exists) {
                        const partnerData = partnerDoc.data();
                        const chatItem = document.createElement('li');
                        chatItem.className = 'chat-item';
                        chatItem.dataset.userId = partnerData.uid;

                        // Determine partner's avatar (direct URL or emoji logo).
                        let partnerAvatarHtml;
                        if (partnerData.profilePicUrl) {
                            partnerAvatarHtml = `<div class="profile-avatar small" style="background-image: url('${partnerData.profilePicUrl}');"></div>`;
                        } else {
                            const partnerLogoClass = getLogoCssClass(partnerData.profileLogo || 'logo-1');
                            partnerAvatarHtml = `<div class="profile-avatar small ${partnerLogoClass}"></div>`;
                        }

                        chatItem.innerHTML = `
                            ${partnerAvatarHtml}
                            <div class="chat-info">
                                <span class="chat-username">@${partnerData.username}</span>
                                <span class="last-message">${chat.lastMessage}</span>
                            </div>
                        `;
                        chatItem.addEventListener('click', () => openChatWindow(partnerData.uid)); // Open chat window on click.
                        recentChatsList.appendChild(chatItem);
                    }
                }
            }, error => {
                console.error("Error loading recent chats listener:", error);
                showToast("Error loading chats. Please check console.", 'error');
                recentChatsList.innerHTML = '<p style="text-align: center; color: red;">Error loading chats.</p>';
            });
    } catch (error) {
        console.error("Error setting up recent chats listener:", error);
        showToast("Error setting up chat listener. Please try again.", 'error');
    }
}

async function openChatWindow(partnerId) {
    if (!currentUser) {
        showToast("Please log in to chat.", 'info');
        return;
    }
    currentChatPartnerId = partnerId;
    messageListContainer.classList.add('hidden'); // Hide chat list.
    chatWindowContainer.classList.remove('hidden'); // Show chat window.
    chatMessages.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; // Show a loading spinner.

    try {
        const partnerDoc = await db.collection('users').doc(partnerId).get();
        if (partnerDoc.exists) {
            chatPartnerUsername.textContent = `@${partnerDoc.data().username}`; // Set chat partner's username.
            // Set chat partner's avatar.
            if (partnerDoc.data().profilePicUrl) {
                chatPartnerAvatar.style.backgroundImage = `url('${partnerDoc.data().profilePicUrl}')`;
                chatPartnerAvatar.className = 'profile-avatar small';
            } else {
                chatPartnerAvatar.style.backgroundImage = 'none';
                const partnerLogoClass = getLogoCssClass(partnerDoc.data().profileLogo || 'logo-1');
                partnerAvatarHtml = `<div class="profile-avatar small ${partnerLogoClass}"></div>`;
            }
        } else {
            chatPartnerUsername.textContent = "@UnknownUser";
            chatPartnerAvatar.style.backgroundImage = 'none';
            chatPartnerAvatar.className = `profile-avatar small ${getLogoCssClass('logo-1')}`;
        }

        // Real-time listener for messages between these two specific users.
        db.collection('messages')
            .where('participants', 'array-contains', currentUser.uid) // Query messages where current user is a participant.
            .orderBy('timestamp', 'asc') // Order messages chronologically.
            .onSnapshot(snapshot => {
                chatMessages.innerHTML = ''; // Clear previous messages.
                snapshot.docs.forEach(doc => {
                    const message = doc.data();
                    // Filter messages relevant *only* to the current chat partner in the UI
                    const isRelevant = (message.senderId === currentUser.uid && message.receiverId === partnerId) ||
                                       (message.senderId === partnerId && message.receiverId === currentUser.uid);
                    // Client-side expiry check for display (Firestore rules enforce true expiry on backend).
                    const isWithin12Hours = (Date.now() - message.timestamp.toMillis()) < (12 * 60 * 60 * 1000);

                    if (isRelevant && isWithin12Hours) {
                        const messageBubble = document.createElement('div');
                        messageBubble.className = `message-bubble ${message.senderId === currentUser.uid ? 'right' : 'left'}`; // Align bubbles.
                        messageBubble.textContent = message.content;
                        chatMessages.appendChild(messageBubble);
                    }
                });
                chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll to latest message.
            }, error => {
                console.error("Error getting chat messages:", error);
                chatMessages.innerHTML = '<p style="text-align: center; color: red;">Error loading messages.</p>';
                showToast("Error loading messages.", 'error');
            });

        // Long press for emoji reactions in chat (similar to posts)
        const emojiPickerChat = chatWindowContainer.querySelector('.emoji-picker-chat');
        messageInput.addEventListener('touchstart', (e) => {
            clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                emojiPickerChat.classList.remove('hidden');
            }, 800);
        }, { passive: true }); // Use passive to avoid blocking native scroll behavior.

        messageInput.addEventListener('touchend', () => {
            clearTimeout(longPressTimer);
        });

        // Hide emoji picker when clicking outside.
        const hideEmojiPickerChat = (e) => {
            if (!emojiPickerChat.contains(e.target) && !messageInput.contains(e.target) && !emojiPickerChat.classList.contains('hidden')) {
                emojiPickerChat.classList.add('hidden');
            }
        };
        document.addEventListener('click', hideEmojiPickerChat); // Listen for clicks on the document to hide picker.


        emojiPickerChat.querySelectorAll('.emoji-option').forEach(emojiOption => {
            emojiOption.addEventListener('click', (e) => {
                const selectedEmoji = e.target.dataset.emoji;
                messageInput.value += ` ${selectedEmoji} `; // Append emoji to input.
                emojiPickerChat.classList.add('hidden'); // Hide picker after selection.
                messageInput.focus(); // Keep focus on input.
            });
        });

    } catch (error) {
        console.error("Error opening chat window:", error);
        showToast("Failed to open chat. Please try again.", 'error');
    }
}

// Back button in chat window to return to recent chats list.
backToChatsBtn.addEventListener('click', () => {
    messageListContainer.classList.remove('hidden'); // Show chat list.
    chatWindowContainer.classList.add('hidden'); // Hide chat window.
    currentChatPartnerId = null; // Clear active chat partner.
    // Ideally, detach Firestore snapshot listener for performance, but requires storing its unsubscribe function.
});

// Send message button in chat window.
sendMessageBtn.addEventListener('click', async () => {
    if (!currentUser || !currentChatPartnerId) {
        showToast("You need to be logged in and select a recipient to send a message.", 'error');
        return;
    }

    const messageContent = messageInput.value.trim();
    if (messageContent === '') {
        showToast("Message cannot be empty.", 'info');
        return;
    }

    try {
        await db.collection('messages').add({
            senderId: currentUser.uid,
            receiverId: currentChatPartnerId,
            content: messageContent,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            participants: [currentUser.uid, currentChatPartnerId], // For efficient querying of conversations.
            read: false // Mark as unread for the receiver.
        });

        messageInput.value = ''; // Clear message input after sending.
        chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll to the bottom of the chat.
        showToast("Message sent!", 'success');
    } catch (error) {
        console.error("Error sending message:", error);
        // Provide user-friendly error feedback.
        if (error.code === 'permission-denied' || error.message.includes('Missing or insufficient permissions')) {
            showToast("Error sending message: Missing or insufficient permissions. Please check Firebase rules.", 'error', 5000);
        } else {
            showToast("Failed to send message. Please try again.", 'error');
        }
    }
});


// --- Comments Feature ---
// Open comments modal for a specific post.
function openCommentsModal(postId) {
    if (!currentUser) {
        showToast("Please log in to view or add comments.", 'info');
        return;
    }
    currentPostIdForComments = postId; // Store the ID of the post for which comments are being viewed.
    commentsModal.classList.remove('hidden'); // Display the comments modal.
    commentsList.innerHTML = '<div class="loader" style="margin: 20px auto;"></div>'; // Show a loading spinner.
    commentsModalTitle.textContent = 'Comments'; // Set modal title.

    // Real-time listener for comments related to this post.
    db.collection('comments')
        .where('postId', '==', postId)
        .orderBy('timestamp', 'asc') // Order comments chronologically.
        .onSnapshot(async (snapshot) => {
            commentsList.innerHTML = ''; // Clear existing comments.
            if (snapshot.empty) {
                commentsList.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">No comments yet. Be the first to comment!</p>';
                return;
            }

            for (const doc of snapshot.docs) {
                const commentData = doc.data();
                const commentUserDoc = await db.collection('users').doc(commentData.userId).get();
                const username = commentUserDoc.exists ? commentUserDoc.data().username : 'Deleted User'; // Display username or 'Deleted User'.

                const commentItem = document.createElement('div');
                commentItem.className = 'comment-item';
                commentItem.innerHTML = `
                    <strong>@${username}</strong>: ${commentData.content}
                    <small>${new Date(commentData.timestamp.toMillis()).toLocaleString()}</small>
                `;
                commentsList.appendChild(commentItem);
            }
            commentsList.scrollTop = commentsList.scrollHeight; // Auto-scroll to the bottom of the comments list.
        }, error => {
            console.error("Error loading comments:", error);
            commentsList.innerHTML = '<p style="text-align: center; color: red;">Error loading comments.</p>';
            showToast("Error loading comments.", 'error');
        });
}

// Add a new comment to the current post.
addCommentBtn.addEventListener('click', async () => {
    if (!currentUser || !currentPostIdForComments) {
        showToast("You need to be logged in and viewing a post to comment.", 'error');
        return;
    }

    const commentContent = newCommentInput.value.trim();
    if (commentContent.length < 1 || commentContent.length > 100) {
        showToast("Comment must be between 1 and 100 characters.", 'error');
        return;
    }

    try {
        await db.collection('comments').add({
            postId: currentPostIdForComments,
            userId: currentUser.uid,
            content: commentContent,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        });

        // Increment the comment count on the post document.
        await db.collection('posts').doc(currentPostIdForComments).update({
            commentCount: firebase.firestore.FieldValue.increment(1)
        });

        newCommentInput.value = ''; // Clear comment input field.
        showToast("Comment added!", 'success');
    } catch (error) {
        console.error("Error adding comment:", error);
        showToast("Failed to add comment. Please try again.", 'error');
    }
});

// Close comments modal.
closeCommentsModalBtn.addEventListener('click', () => {
    commentsModal.classList.add('hidden');
    currentPostIdForComments = null; // Clear the post ID.
});


// --- Search Functionality ---
searchBtn.addEventListener('click', () => performSearch()); // Trigger search on button click.
searchQueryInput.addEventListener('keypress', (e) => { // Trigger search on Enter key press.
    if (e.key === 'Enter') {
        performSearch();
    }
});

async function performSearch() {
    const query = searchQueryInput.value.trim().toLowerCase();
    searchUserList.innerHTML = ''; // Clear previous user results.
    searchPostList.innerHTML = ''; // Clear previous post results.
    noSearchResults.classList.add('hidden'); // Hide 'no results' message initially.

    if (query === '') {
        showToast("Please enter a search query.", 'info');
        return;
    }

    let foundResults = false;

    // Search Users by username.
    try {
        const userSnapshot = await db.collection('users')
            .where('username', '>=', query) // Starts with query
            .where('username', '<=', query + '\uf8ff') // Ends with query (approx)
            .limit(10) // Limit results.
            .get();

        if (!userSnapshot.empty) {
            foundResults = true;
            userSnapshot.docs.forEach(doc => {
                const userData = { id: doc.id, ...doc.data() };
                const userItem = document.createElement('li');
                userItem.className = 'search-user-item';
                userItem.dataset.userId = userData.id;

                // Determine user avatar.
                let userAvatarHtml;
                if (userData.profilePicUrl) {
                    userAvatarHtml = `<div class="profile-avatar small" style="background-image: url('${userData.profilePicUrl}');"></div>`;
                } else {
                    const userLogoClass = getLogoCssClass(userData.profileLogo || 'logo-1');
                    userAvatarHtml = `<div class="profile-avatar small ${userLogoClass}"></div>`;
                }

                userItem.innerHTML = `
                    ${userAvatarHtml}
                    <span class="search-username">@${userData.username}</span>
                    <button class="btn small primary-btn follow-btn" data-target-id="${userData.id}"></button>
                `;
                searchUserList.appendChild(userItem);

                const followBtn = userItem.querySelector('.follow-btn');
                if (currentUser.uid === userData.id) { // Hide button if it's current user's profile.
                    followBtn.classList.add('hidden');
                } else {
                    // Update follow button status (Follow/Following).
                    db.collection('users').doc(currentUser.uid).get().then(doc => {
                        const followingList = doc.data().following || [];
                        if (followingList.includes(userData.id)) {
                            followBtn.textContent = 'Following';
                            followBtn.classList.add('secondary-btn');
                            followBtn.classList.remove('primary-btn');
                        } else {
                            followBtn.textContent = 'Follow';
                            followBtn.classList.add('primary-btn');
                            followBtn.classList.remove('secondary-btn');
                        }
                    });
                }

                followBtn.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent opening profile when clicking button.
                    const targetId = e.target.dataset.targetId;
                    if (e.target.textContent === 'Follow') {
                        await handleFollow(targetId);
                        e.target.textContent = 'Following';
                        e.target.classList.add('secondary-btn');
                        e.target.classList.remove('primary-btn');
                    } else {
                        await handleUnfollow(targetId);
                        e.target.textContent = 'Follow';
                        e.target.classList.add('primary-btn');
                        e.target.classList.remove('secondary-btn');
                    }
                });
                userItem.addEventListener('click', () => openUserProfile(userData.id)); // Open user profile on click.
            });
        }
    } catch (error) {
        console.error("Error searching users:", error);
        showToast("Error searching users. Please check console.", 'error');
    }

    // Search Posts by content keyword (basic client-side match).
    // Note: For large scale full-text search, Firebase functions + Algolia or a similar solution is recommended.
    try {
        const postSnapshot = await db.collection('posts')
            .where('expiryTime', '>', firebase.firestore.Timestamp.now())
            .orderBy('expiryTime', 'desc')
            .limit(10)
            .get();

        postSnapshot.docs.forEach(doc => {
            const postData = { id: doc.id, ...doc.data() };
            // Security rules will ultimately decide if user can read the private posts found.
            if (postData.content && postData.content.toLowerCase().includes(query)) {
                foundResults = true;
                searchPostList.appendChild(createPostElement(postData));
            }
        });
    } catch (error) {
        console.error("Error searching posts:", error);
        showToast("Error searching posts. Please check console.", 'error');
    }

    if (!foundResults) {
        noSearchResults.classList.remove('hidden'); // Show 'No results' message if nothing found.
    }
}

// --- Post Options (Report, Delete, Repost) ---
async function handleReportPost(postId) {
    if (!currentUser) {
        showToast("Please log in to report posts.", 'info');
        return;
    }
    try {
        await db.collection('reports').add({
            postId: postId,
            reportedBy: currentUser.uid,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            status: 'pending' // Initial status
        });
        showToast("Post reported successfully. We will review it.", 'info');
    } catch (error) {
        console.error("Error reporting post:", error);
        showToast("Failed to report post. Please try again.", 'error');
    }
}

async function handleRepost(postId) {
    if (!currentUser) {
        showToast("Please log in to repost.", 'info');
        return;
    }
    try {
        const userDocRef = db.collection('users').doc(currentUser.uid);
        const userDoc = await userDocRef.get();
        const userData = userDoc.data();
        const currentReposts = userData.reposts || [];

        if (currentReposts.includes(postId)) {
            showToast("You have already reposted this.", 'info');
            return;
        }

        await userDocRef.update({
            reposts: firebase.firestore.FieldValue.arrayUnion(postId) // Add post ID to user's reposts array.
        });
        showToast("Post reposted to your profile!", 'success');
    } catch (error) {
        console.error("Error reposting:", error);
        showToast("Failed to repost. Please try again.", 'error');
    }
}


async function handleDeletePost(postId, postElement, isMonetized) {
    if (!currentUser) {
        showToast("Please log in to delete posts.", 'info');
        return;
    }

    try {
        const postRef = db.collection('posts').doc(postId);
        const postDoc = await postRef.get();

        if (postDoc.exists && postDoc.data().userId === currentUser.uid) { // Only owner can delete.
            if (confirm("Are you sure you want to delete this post? This cannot be undone.")) {
                // Perform deletion in a transaction to ensure atomicity for related data.
                await db.runTransaction(async (transaction) => {
                    transaction.delete(postRef); // Delete the main post document.

                    // Delete related comments (a Cloud Function is ideal for full cascade deletion).
                    const commentsSnapshot = await db.collection('comments').where('postId', '==', postId).get();
                    commentsSnapshot.docs.forEach(commentDoc => {
                        transaction.delete(db.collection('comments').doc(commentDoc.id));
                    });

                    // Delete the postViews record for this post.
                    const postViewsRef = db.collection('postViews').doc(postId);
                    const postViewsDoc = await transaction.get(postViewsRef);
                    if (postViewsDoc.exists) {
                         transaction.delete(postViewsRef);
                    }

                    // Decrement the user's total post count.
                    const userRef = db.collection('users').doc(currentUser.uid);
                    transaction.update(userRef, {
                        postCount: firebase.firestore.FieldValue.increment(-1)
                    });
                });

                postElement.remove(); // Remove post from UI.
                showToast("Post deleted successfully.", 'success');
            }
        } else {
            showToast("You can only delete your own posts.", 'error');
        }
    } catch (error) {
        console.error("Error deleting post:", error);
        showToast("Failed to delete post. Please try again.", 'error');
    }
}

// --- Text-to-Speech Feature ---
function handleSpeakPost(text) {
    if (!('speechSynthesis' in window)) { // Check if browser supports SpeechSynthesis API.
        showToast("Your browser does not support text-to-speech.", 'error');
        return;
    }

    if (synth.speaking) { // If speech is already ongoing, cancel it.
        synth.cancel();
        // If it was the same text, toggle off speech; otherwise, it will start new speech.
        if (currentSpeechUtterance && currentSpeechUtterance.text === text) {
            currentSpeechUtterance = null; // Stop current reading if it's a toggle.
            showToast("Speech stopped.", 'info');
            return;
        }
    }

    // Clean HTML tags and markdown links/images for clearer speech.
    const cleanText = text.replace(/<[^>]*>/g, '') // Remove HTML tags
                        .replace(/\[.*?\]\(.*?\)/g, '') // Remove markdown links
                        .replace(/!\[.*?\]\(.*?\)/g, ''); // Remove markdown images/videos

    const utterance = new SpeechSynthesisUtterance(cleanText); // Create a new speech utterance.
    utterance.lang = 'en-US'; // Set language (can be dynamic).
    utterance.pitch = 1; // Standard pitch.
    utterance.rate = 1; // Standard speed.

    synth.speak(utterance); // Start speech.
    currentSpeechUtterance = utterance; // Store for future reference (e.g., to stop it).

    utterance.onend = () => { // Reset when speech ends.
        currentSpeechUtterance = null;
    };
    showToast("Speaking post...", 'info');
}

// --- Post Translation Feature ---
function handleTranslatePost(text) {
    if (!currentUser) {
        showToast("Please log in to translate posts.", 'info');
        return;
    }
    // This functionality requires integration with a third-party translation API (e.g., Google Cloud Translation API).
    // Client-side translation is not practical without external API due to library size and complexity.
    showToast("Translation feature coming soon! (Requires external API integration)", 'info', 4000);

    /* Example of how you *might* call a Firebase Cloud Function for translation:
    // Make sure you have the Firebase Cloud Functions SDK initialized if using it in JS.
    // const functions = firebase.functions();
    // if (location.hostname === "localhost") {
    //     functions.useEmulator("localhost", 5001); // Use local emulator for development
    // }
    
    // functions.httpsCallable('translateText')({ text: text, targetLanguage: 'hi' }) // Target language can be user-selected.
    //     .then(result => {
    //         console.log('Translated text:', result.data.translatedText);
    //         showToast(`Translated to Hindi: ${result.data.translatedText}`, 'success', 5000);
    //         // Here, you would update the post's displayed content or open a translation modal.
    //     })
    //     .catch(error => {
    //         console.error("Translation error via Cloud Function:", error);
    //         showToast(`Failed to translate post: ${error.message}`, 'error');
    //     });
    */
}


// --- Earnings Screen Logic ---
async function loadEarningsPage() {
    if (!currentUser) {
        showToast("Please log in to view your earnings.", 'info');
        return;
    }
    try {
        // Fetch current user's earning data from Firestore.
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (userDoc.exists) {
            const userData = userDoc.data();
            const monetizedViews = userData.monetizedViewsCount || 0;
            const unmonetizedViews = userData.unmonetizedViewsCount || 0;
            const earnedAmount = userData.earnedAmount || 0.00;

            // Update UI elements with fetched data.
            totalMonetizedViewsSpan.textContent = formatNumber(monetizedViews);
            totalUnmonetizedViewsSpan.textContent = formatNumber(unmonetizedViews);
            estimatedEarningsSpan.textContent = `${earnedAmount.toFixed(2)} $`;

            const WITHDRAWAL_THRESHOLD = 100000; // Minimum monetized views for withdrawal (1 Lakh).
            if (monetizedViews >= WITHDRAWAL_THRESHOLD) {
                withdrawBtn.disabled = false;
                withdrawBtn.classList.add('primary-btn');
                withdrawBtn.classList.remove('secondary-btn');
                withdrawalStatusDiv.classList.add('hidden'); // Hide status if eligible.
            } else {
                withdrawBtn.disabled = true; // Disable button if not eligible.
                withdrawBtn.classList.add('secondary-btn');
                withdrawBtn.classList.remove('primary-btn');
                withdrawalStatusDiv.classList.remove('hidden'); // Show status message.
                withdrawalStatusDiv.textContent = `You need ${formatNumber(WITHDRAWAL_THRESHOLD)} monetized views to withdraw. You currently have ${formatNumber(monetizedViews)}.`;
            }
        } else {
            showToast("Your earning data is not available. Please try again.", 'error');
        }
    } catch (error) {
        console.error("Error loading earnings data:", error);
        showToast("Error loading earnings. Please try again.", 'error');
    }
}

// Open the withdrawal modal.
withdrawBtn.addEventListener('click', () => {
    if (!currentUser) { // Double check login status.
        showToast("Please log in to withdraw earnings.", 'info');
        return;
    }
    withdrawalModal.classList.remove('hidden'); // Show the modal.
    withdrawalDetailsReview.classList.add('hidden'); // Ensure review section is hidden initially.

    // Display current monetized views in the modal.
    const monetizedViews = parseInt(totalMonetizedViewsSpan.textContent.replace(/[^0-9.]/g, '')) || 0;
    withdrawalViewsDisplay.textContent = formatNumber(monetizedViews);

    // Reset withdrawal form fields.
    withdrawalMethodSelect.value = 'upi';
    withdrawalIdLabel.textContent = 'UPI ID:';
    withdrawalIdInput.value = '';
    withdrawalIdInput.placeholder = 'Enter UPI ID';
    confirmWithdrawalBtn.classList.remove('hidden'); // Show confirm button.
});

// Update input label and placeholder based on withdrawal method selection.
withdrawalMethodSelect.addEventListener('change', (e) => {
    if (e.target.value === 'upi') {
        withdrawalIdLabel.textContent = 'UPI ID:';
        withdrawalIdInput.placeholder = 'Enter UPI ID (e.g., example@bank)';
    } else {
        withdrawalIdLabel.textContent = 'PayPal Email:';
        withdrawalIdInput.placeholder = 'Enter PayPal Email';
    }
});

// Confirm withdrawal details entered by the user.
confirmWithdrawalBtn.addEventListener('click', () => {
    const method = withdrawalMethodSelect.value;
    const id = withdrawalIdInput.value.trim();
    const views = withdrawalViewsDisplay.textContent;

    if (!id) { // Validate if ID field is empty.
        showToast("Please enter your UPI ID or PayPal Email.", 'error');
        return;
    }

    // Populate the review section.
    reviewMethodSpan.textContent = method === 'upi' ? 'UPI' : 'PayPal';
    reviewIdSpan.textContent = id;
    reviewViewsSpan.textContent = views;

    withdrawalDetailsReview.classList.remove('hidden'); // Show review section.
    confirmWithdrawalBtn.classList.add('hidden'); // Hide the "Check Details" button.
});

// Allow user to edit details after review.
editWithdrawalBtn.addEventListener('click', () => {
    withdrawalDetailsReview.classList.add('hidden'); // Hide review section.
    confirmWithdrawalBtn.classList.remove('hidden'); // Show "Check Details" button again.
});

// Send withdrawal request to Firestore (simulated backend call).
sendWithdrawalRequestBtn.addEventListener('click', async () => {
    if (!currentUser) return; // Must be logged in.

    const method = withdrawalMethodSelect.value;
    const id = withdrawalIdInput.value.trim();
    // Re-fetch current monetized views and earnings to ensure accuracy before submitting.
    const userDoc = await db.collection('users').doc(currentUser.uid).get();
    const currentMonetizedViews = userDoc.exists ? (userDoc.data().monetizedViewsCount || 0) : 0;
    const estimatedEarnings = userDoc.exists ? (userDoc.data().earnedAmount || 0.00) : 0.00;

    if (!id) {
        showToast("Withdrawal ID cannot be empty.", 'error');
        return;
    }

    const WITHDRAWAL_THRESHOLD = 100000;
    if (currentMonetizedViews < WITHDRAWAL_THRESHOLD) {
        showToast(`Withdrawal requires ${formatNumber(WITHDRAWAL_THRESHOLD)} monetized views.`, 'error', 5000);
        return;
    }

    try {
        console.log("Simulating withdrawal request submission and saving to Firestore...");
        
        // Save the request in a 'withdrawalRequests' collection for admin to process.
        await db.collection('withdrawalRequests').add({
            userId: currentUser.uid,
            username: myProfileUsername.textContent.replace('@', ''), // Use the displayed username.
            method: method,
            id: id,
            monetizedViewsAtRequest: currentMonetizedViews, // Record views at the time of request.
            estimatedAmount: estimatedEarnings,
            requestTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
            status: 'pending' // Initial status for admin processing.
        });

        // IMPORTANT: In a production app, the reset of `monetizedViewsCount` and `earnedAmount`
        // should happen *only after* an admin has successfully processed and sent the payment.
        // This is typically handled by a Firebase Cloud Function triggered by the admin marking a request as 'completed'.
        // For this client-side demo, we reset them immediately to simulate the process.
        await db.collection('users').doc(currentUser.uid).update({
            monetizedViewsCount: 0,
            earnedAmount: 0.00
        });

        withdrawalModal.classList.add('hidden'); // Hide the modal after submission.
        showToast("Withdrawal request sent! You will receive payment in 1-15 business days.", 'success', 8000);
        loadEarningsPage(); // Reload earnings data to reflect reset.
    } catch (error) {
        console.error("Error sending withdrawal request:", error);
        showToast("Failed to send withdrawal request. Please try again. Error: " + (error.message || 'Unknown error'), 'error', 6000);
    }
});

cancelWithdrawalBtn.addEventListener('click', () => {
    withdrawalModal.classList.add('hidden');
});
```
